<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>OKLab Color Picker</title>

  <style>
    /* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font: 13px/1.4 'Segoe UI', system-ui, sans-serif;
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 16px;
      user-select: none;
    }

    /* â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }

    .toolbar button {
      flex: 1;
      padding: 7px;
      border: 1px solid #45475a;
      background: #313244;
      color: #cdd6f4;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .toolbar button:hover {
      background: #45475a;
    }

    .toolbar button.active {
      background: #a6e3a1;
      color: #1e1e2e;
      border-color: #a6e3a1;
    }

    .toolbar button.active-warn {
      background: #f9e2af;
      color: #1e1e2e;
      border-color: #f9e2af;
    }

    /* â”€â”€ Working Color Space Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .cs-bar {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 12px;
      font-size: 11px;
    }

    .cs-bar .cs-label {
      color: #6c7086;
    }

    .cs-bar .cs-name {
      color: #89b4fa;
      font-weight: 600;
      flex: 1;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .cs-bar button {
      padding: 4px 10px;
      border: 1px solid #45475a;
      background: #313244;
      color: #cdd6f4;
      border-radius: 5px;
      cursor: pointer;
      font-size: 11px;
      white-space: nowrap;
    }

    .cs-bar button:hover {
      background: #45475a;
    }

    #icc-file-input {
      display: none;
    }

    /* â”€â”€ 2D Picker (a, b axes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .picker-wrap {
      position: relative;
      width: 300px;
      margin: 0 auto;
    }

    #ab-picker {
      display: block;
      border-radius: 8px;
      cursor: crosshair;
    }

    /* Axis labels positioned around the picker */
    .axis-label {
      position: absolute;
      font-size: 9px;
      color: #6c7086;
      pointer-events: none;
    }

    .axis-label.top {
      top: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.bottom {
      bottom: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.left {
      left: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg);
    }

    .axis-label.right {
      right: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(90deg);
    }

    /* â”€â”€ Sliders (Lightness, Chroma, Hue) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .slider-canvas {
      display: block;
      border-radius: 6px;
      cursor: crosshair;
      margin: 16px auto 0;
    }

    .slider-label {
      display: block;
      width: 300px;
      margin: 6px auto 0;
      font-size: 9px;
      color: #6c7086;
      text-align: center;
    }

    /* â”€â”€ Info Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #info {
      margin: 14px auto 0;
      width: 300px;
    }

    .color-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    #color-preview {
      width: 56px;
      height: 56px;
      border-radius: 8px;
      border: 2px solid #45475a;
      flex-shrink: 0;
    }

    #oklab-values {
      font: 12px 'Cascadia Code', 'Consolas', monospace;
      line-height: 1.7;
    }

    /* Hex value rows */
    .hex-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      font: 12px 'Cascadia Code', 'Consolas', monospace;
    }

    .hex-row label {
      min-width: 72px;
      color: #6c7086;
      font-family: inherit;
    }

    .hex-value {
      padding: 2px 8px;
      background: #313244;
      border-radius: 4px;
    }

    .copy-button {
      padding: 2px 7px;
      border: none;
      background: #45475a;
      color: #cdd6f4;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .copy-button:hover {
      background: #585b70;
    }

    /* Gamut indicators */
    .in-gamut {
      color: #a6e3a1;
      font-size: 11px;
    }

    .out-of-gamut {
      color: #f38ba8;
      font-size: 11px;
    }

    /* â”€â”€ Lighting Lab Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #lighting-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
      opacity: 0;
      margin: 0 auto;
      width: 300px;
    }

    #lighting-panel.open {
      max-height: 900px;
      opacity: 1;
      margin: 14px auto 0;
    }

    /* Intensity slider */
    .intensity-row {
      display: flex;
      align-items: center;
      gap: 8px;
      margin: 10px auto 0;
      width: 300px;
    }

    .intensity-row label {
      font-size: 11px;
      color: #a6adc8;
      white-space: nowrap;
      min-width: 62px;
    }

    .intensity-track {
      flex: 1;
      height: 18px;
      border-radius: 6px;
      cursor: crosshair;
      position: relative;
      background: linear-gradient(to right, #1e1e2e, #f9e2af);
      border: 1px solid #45475a;
    }

    .intensity-fill {
      position: absolute;
      left: 0; top: 0; bottom: 0;
      border-radius: 5px;
      background: #f9e2af;
      pointer-events: none;
      opacity: 0.25;
    }

    .intensity-thumb {
      position: absolute;
      top: -2px;
      width: 4px;
      height: 22px;
      border-radius: 2px;
      background: #cdd6f4;
      border: 1px solid #1e1e2e;
      pointer-events: none;
      transform: translateX(-50%);
    }

    .intensity-value {
      font-size: 11px;
      color: #cdd6f4;
      font-weight: 600;
      min-width: 38px;
      text-align: right;
      font-variant-numeric: tabular-nums;
    }

    .lighting-divider {
      border: none;
      border-top: 1px solid #45475a;
      margin: 10px 0;
    }

    .lighting-header {
      font-size: 11px;
      color: #a6adc8;
      text-align: center;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }

    /* Mode selector tabs for Albedo / Light */
    .mode-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 10px;
    }

    .mode-tabs button {
      flex: 1;
      padding: 5px 8px;
      border: 1px solid #45475a;
      background: #313244;
      color: #6c7086;
      border-radius: 5px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.15s, color 0.15s;
    }

    .mode-tabs button:hover {
      background: #45475a;
      color: #cdd6f4;
    }

    .mode-tabs button.tab-active {
      background: #89b4fa;
      color: #1e1e2e;
      border-color: #89b4fa;
      font-weight: 600;
    }

    /* Equation row: Albedo Ã— Light = Result */
    .lighting-equation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin: 8px 0;
    }

    .lighting-swatch-wrap {
      text-align: center;
    }

    .lighting-swatch-wrap .swatch-label {
      font-size: 9px;
      color: #6c7086;
      margin-bottom: 3px;
    }

    .lighting-swatch {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      border: 2px solid #45475a;
      cursor: pointer;
    }

    .lighting-swatch.read-only {
      cursor: default;
    }

    .lighting-swatch.selected {
      border-color: #89b4fa;
      box-shadow: 0 0 0 2px rgba(137, 180, 250, 0.35);
    }

    .lighting-operator {
      font-size: 18px;
      color: #6c7086;
      padding: 12px 0 0;
    }

    /* Result info in lighting panel */
    .lighting-result-info {
      margin-top: 8px;
      font: 12px 'Cascadia Code', 'Consolas', monospace;
      line-height: 1.6;
    }

    .lighting-result-info .label {
      color: #6c7086;
    }

    /* Mini a,b map for result */
    #result-ab-map {
      display: block;
      border-radius: 6px;
      margin: 8px auto 0;
    }
  </style>
</head>

<body>

  <!-- â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="toolbar">
    <button id="always-on-top-button" onclick="toggleAlwaysOnTop()">ğŸ“Œ Always on Top</button>
    <button onclick="pickColor()">ğŸ’§ Pick Color <kbd style="opacity: 0.6; font-size: 10px">Alt+C</kbd></button>
  </div>

  <!-- â”€â”€ Working Color Space Bar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="cs-bar">
    <span class="cs-label">Working CS:</span>
    <span class="cs-name" id="cs-name-display" title="">Display P3</span>
    <button onclick="document.getElementById('icc-file-input').click()">ğŸ“‚ Import ICC</button>
    <button onclick="resetWorkingCS()" title="Reset to default (P3 or sRGB)">â†º</button>
    <input type="file" id="icc-file-input" accept=".icm,.icc" onchange="handleICCImport(this)">
  </div>

  <!-- â”€â”€ 2D Color Picker (a, b axes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="picker-wrap">
    <canvas id="ab-picker" width="300" height="300"></canvas>
    <span class="axis-label top">+b (yellow)</span>
    <span class="axis-label bottom">âˆ’b (blue)</span>
    <span class="axis-label left">âˆ’a (green)</span>
    <span class="axis-label right">+a (red)</span>
  </div>

  <!-- â”€â”€ Lightness Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="lightness-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">L: Lightness (0 â†’ 1)</span>

  <!-- â”€â”€ Chroma Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="chroma-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">C: Chroma (0 â†’ 0.4)</span>

  <!-- â”€â”€ Hue Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="hue-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">h: Hue (0Â° â†’ 360Â°)</span>

  <!-- â”€â”€ Color Info Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="info">
    <!-- Preview swatch + OKLab values -->
    <div class="color-row">
      <div id="color-preview"></div>
      <div id="oklab-values"></div>
    </div>

    <!-- sRGB hex code -->
    <div class="hex-row">
      <label>sRGB:</label>
      <span class="hex-value" id="srgb-hex"></span>
      <span id="srgb-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'srgb-hex')">ğŸ“‹</button>
    </div>

    <!-- Display P3 hex code (always shown) -->
    <div class="hex-row">
      <label>Display P3:</label>
      <span class="hex-value" id="display-p3-hex"></span>
      <span id="display-p3-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'display-p3-hex')">ğŸ“‹</button>
    </div>

    <!-- Working CS hex code (hidden when working CS is P3 or sRGB) -->
    <div class="hex-row" id="working-cs-row" style="display:none">
      <label id="working-cs-hex-label">Working:</label>
      <span class="hex-value" id="working-hex"></span>
      <span id="working-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'working-hex')">ğŸ“‹</button>
    </div>

    <!-- Raw CSS oklab() value -->
    <div class="hex-row">
      <label>CSS:</label>
      <span class="hex-value" id="css-oklab-value"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'css-oklab-value')">ğŸ“‹</button>
    </div>
  </div>

  <!-- â”€â”€ Lighting Lab Toggle â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="toolbar" style="width:300px; margin:10px auto 0;">
    <button id="lighting-toggle-button" onclick="toggleLightingPanel()">ğŸ’¡ Lighting Lab</button>
  </div>

  <!-- â”€â”€ Lighting Lab Panel (slide-out) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="lighting-panel">
    <hr class="lighting-divider">
    <div class="lighting-header">LIGHTING LAB</div>

    <!-- Mode tabs: which color the main picker edits -->
    <div class="mode-tabs">
      <button id="tab-albedo" class="tab-active" onclick="setEditTarget('albedo')">ğŸ¨ Albedo</button>
      <button id="tab-light" onclick="setEditTarget('light')">â˜€ï¸ Light Color</button>
    </div>

    <!-- Equation: Albedo Ã— Light = Result -->
    <div class="lighting-equation">
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Albedo</div>
        <div id="swatch-albedo" class="lighting-swatch selected" onclick="setEditTarget('albedo')"></div>
      </div>
      <div class="lighting-operator">Ã—</div>
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Light</div>
        <div id="swatch-light" class="lighting-swatch" onclick="setEditTarget('light')"></div>
      </div>
      <div class="lighting-operator">=</div>
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Result</div>
        <div id="swatch-result" class="lighting-swatch read-only"></div>
      </div>
    </div>

    <!-- Light Intensity slider -->
    <div class="intensity-row">
      <label>â˜€ï¸ Intensity:</label>
      <div class="intensity-track" id="intensity-track">
        <div class="intensity-fill" id="intensity-fill"></div>
        <div class="intensity-thumb" id="intensity-thumb"></div>
      </div>
      <span class="intensity-value" id="intensity-value">1.00</span>
    </div>

    <!-- Result mini a,b map (read-only) -->
    <canvas id="result-ab-map" width="150" height="150"></canvas>
    <span class="slider-label" style="width:150px; margin-top:4px;">Result in OKLab a,b plane</span>

    <!-- Result numeric values -->
    <div class="lighting-result-info" id="lighting-result-values"></div>
    <div class="hex-row" style="margin-top:6px">
      <label>sRGB:</label>
      <span class="hex-value" id="result-srgb-hex"></span>
      <span id="result-srgb-gamut"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-srgb-hex')">ğŸ“‹</button>
    </div>
    <div class="hex-row">
      <label>Display P3:</label>
      <span class="hex-value" id="result-p3-hex"></span>
      <span id="result-p3-gamut"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-p3-hex')">ğŸ“‹</button>
    </div>
    <div class="hex-row" id="result-wcs-row" style="display:none">
      <label id="result-wcs-label">Working:</label>
      <span class="hex-value" id="result-wcs-hex"></span>
      <span id="result-wcs-gamut"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-wcs-hex')">ğŸ“‹</button>
    </div>
    <div class="hex-row">
      <label>CSS:</label>
      <span class="hex-value" id="result-css-value"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-css-value')">ğŸ“‹</button>
    </div>
  </div>


  <script>
    const { ipcRenderer } = require('electron');


    // ================================================================
    //  COLOR MATH
    //  Conversion functions between OKLab, linear sRGB, and Display P3.
    //  All use linear-light (pre-gamma) values unless noted otherwise.
    //  Matrix coefficients from https://bottosson.github.io/posts/oklab/
    // ================================================================

    /**
     * Convert OKLab (L, a, b) â†’ linear sRGB (r, g, b).
     *
     * Steps:
     *   1. OKLab â†’ LMS (cone response, cubed-root space)
     *   2. Undo cube root to get linear LMS
     *   3. Linear LMS â†’ linear sRGB via 3Ã—3 matrix
     */
    function oklabToLinearSRGB(L, a, b) {
      // Step 1: OKLab â†’ LMS (cube-root encoded)
      const lCubeRoot = L + 0.3963377774 * a + 0.2158037573 * b;
      const mCubeRoot = L - 0.1055613458 * a - 0.0638541728 * b;
      const sCubeRoot = L - 0.0894841775 * a - 1.2914855480 * b;

      // Step 2: Undo the cube root â†’ linear LMS
      const lLinear = lCubeRoot ** 3;
      const mLinear = mCubeRoot ** 3;
      const sLinear = sCubeRoot ** 3;

      // Step 3: LMS â†’ linear sRGB (3Ã—3 matrix multiply)
      const red   =  4.0767416621 * lLinear - 3.3077115913 * mLinear + 0.2309699292 * sLinear;
      const green = -1.2684380046 * lLinear + 2.6097574011 * mLinear - 0.3413193965 * sLinear;
      const blue  = -0.0041960863 * lLinear - 0.7034186147 * mLinear + 1.7076147010 * sLinear;

      return [red, green, blue];
    }

    /**
     * Convert linear sRGB (r, g, b) â†’ linear Display P3 (r, g, b).
     *
     * This is a direct 3Ã—3 matrix transform between the two RGB spaces.
     * Both share the same whitepoint (D65) but have different primaries.
     */
    function linearSRGBToLinearP3(r, g, b) {
      return [
        0.8224621209 * r + 0.1775378791 * g,
        0.0331941826 * r + 0.9668058174 * g,
        0.0170826307 * r + 0.0723974407 * g + 0.9105199286 * b
      ];
    }

    /**
     * Convert linear Display P3 (r, g, b) â†’ linear sRGB (r, g, b).
     *
     * This is the inverse of linearSRGBToLinearP3.
     * Used when interpreting eyedropper-picked colors as display-native P3.
     */
    function linearP3ToLinearSRGB(r, g, b) {
      return [
         1.2249401762 * r - 0.2249401762 * g,
        -0.0420569549 * r + 1.0420569549 * g,
        -0.0196375546 * r - 0.0786360236 * g + 1.0982735782 * b
      ];
    }

    // ================================================================
    //  OKLab â†” OKLCH CONVERSION
    //  OKLCH is the cylindrical (polar) form of OKLab:
    //    C = chroma = sqrt(aÂ² + bÂ²)
    //    h = hue    = atan2(b, a)  (in degrees, 0â€“360)
    // ================================================================

    /**
     * Convert OKLab (a, b) â†’ OKLCH (C, h).
     * Returns [chroma, hueDegrees].
     */
    function oklabToOklch(a, b) {
      const chroma = Math.sqrt(a * a + b * b);
      let hueDegrees = Math.atan2(b, a) * (180 / Math.PI);
      if (hueDegrees < 0) hueDegrees += 360;
      return [chroma, hueDegrees];
    }

    /**
     * Convert OKLCH (C, h) â†’ OKLab (a, b).
     * hue is in degrees.
     */
    function oklchToOklab(chroma, hueDegrees) {
      const hueRadians = hueDegrees * (Math.PI / 180);
      const a = chroma * Math.cos(hueRadians);
      const b = chroma * Math.sin(hueRadians);
      return [a, b];
    }


    /**
     * Convert linear sRGB (r, g, b) â†’ OKLab (L, a, b).
     *
     * Steps:
     *   1. Linear sRGB â†’ linear LMS via 3Ã—3 matrix
     *   2. Cube root of LMS (perceptual compression)
     *   3. Cube-root LMS â†’ OKLab via 3Ã—3 matrix
     */
    function linearSRGBToOKLab(r, g, b) {
      // Step 1: Linear sRGB â†’ linear LMS
      const lLinear = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
      const mLinear = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
      const sLinear = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

      // Step 2: Cube root (perceptual non-linearity)
      const lRoot = Math.cbrt(lLinear);
      const mRoot = Math.cbrt(mLinear);
      const sRoot = Math.cbrt(sLinear);

      // Step 3: Cube-root LMS â†’ OKLab
      const L =  0.2104542553 * lRoot + 0.7936177850 * mRoot - 0.0040720468 * sRoot;
      const a =  1.9779984951 * lRoot - 2.4285922050 * mRoot + 0.4505937099 * sRoot;
      const ob = 0.0259040371 * lRoot + 0.7827717662 * mRoot - 0.8086757660 * sRoot;

      return [L, a, ob];
    }


    // ================================================================
    //  GAMMA / UTILITY FUNCTIONS
    // ================================================================

    /**
     * Apply sRGB gamma encoding (linear â†’ gamma-encoded).
     * Input is clamped to [0, 1] before encoding.
     * The sRGB transfer function has a linear segment near zero
     * and a power curve for the rest.
     */
    function linearToGamma(linearValue) {
      const clamped = Math.max(0, Math.min(1, linearValue));
      if (clamped >= 0.0031308) {
        return 1.055 * (clamped ** (1 / 2.4)) - 0.055;
      }
      return 12.92 * clamped;
    }

    /**
     * Remove sRGB gamma encoding (gamma-encoded â†’ linear).
     * Inverse of linearToGamma().
     */
    function gammaToLinear(gammaValue) {
      if (gammaValue >= 0.04045) {
        return ((gammaValue + 0.055) / 1.055) ** 2.4;
      }
      return gammaValue / 12.92;
    }

    /** Clamp a value to the [0, 1] range. */
    function clamp01(value) {
      return Math.max(0, Math.min(1, value));
    }

    /**
     * Check whether (r, g, b) values fall within the [0, 1] gamut.
     * A small tolerance (Â±0.0005) is used to avoid false negatives
     * from floating-point rounding in the matrix conversions.
     */
    function isInGamut(r, g, b) {
      const TOLERANCE = 5e-4;
      return (
        r >= -TOLERANCE && r <= 1 + TOLERANCE &&
        g >= -TOLERANCE && g <= 1 + TOLERANCE &&
        b >= -TOLERANCE && b <= 1 + TOLERANCE
      );
    }

    /**
     * Convert gamma-encoded (r, g, b) in [0,1] to a hex color string.
     * Example: (1, 0.5, 0) â†’ "#ff8000"
     */
    function rgbToHex(r, g, b) {
      const toByteHex = (value) =>
        Math.round(clamp01(value) * 255)
          .toString(16)
          .padStart(2, '0');
      return '#' + toByteHex(r) + toByteHex(g) + toByteHex(b);
    }

    /** Convert a linear channel value to a 0â€“255 byte for ImageData. */
    function linearToColorByte(linearValue) {
      return Math.round(linearToGamma(linearValue) * 255);
    }


    // ================================================================
    //  APPLICATION STATE
    // ================================================================

    /** Current OKLab color components */
    let currentL = 0.7;   // Lightness: 0 (black) to 1 (white)
    let currentA = 0.0;   // Greenâ€“Red axis: roughly âˆ’0.4 to +0.4
    let currentB = 0.0;   // Blueâ€“Yellow axis: roughly âˆ’0.4 to +0.4

    /** Whether the window is set to always-on-top */
    let isAlwaysOnTop = true;

    /** Lighting Lab state */
    let isLightingOpen = false;
    let editTarget = 'albedo';  // 'albedo' or 'light'

    // Albedo color (OKLab) â€” initialized to current picker color
    let albedoL = 0.7, albedoA = 0.0, albedoB = 0.0;
    // Light color (OKLab) â€” initialized to white (neutral)
    let lightL = 1.0, lightA = 0.0, lightB = 0.0;
    // Physical linear intensity multiplier for the light (default 1.0)
    let lightIntensity = 1.0;
    const INTENSITY_MAX = 10.0;

    // â”€â”€ Color Selection History â”€â”€
    // Three independent history stacks: main picker, albedo, and light.
    // Each entry is [L, a, b]. Position tracks where we are in the list.
    const historyMain   = { entries: [[0.7, 0.0, 0.0]], pos: 0 };
    const historyAlbedo = { entries: [[0.7, 0.0, 0.0]], pos: 0 };
    const historyLight  = { entries: [[1.0, 0.0, 0.0]], pos: 0 };
    const MAX_HISTORY = 200;

    // â”€â”€ Persistence â”€â”€
    // Stores the raw ICC profile bytes so the custom working CS survives restarts.
    let iccProfileBase64 = null;

    /** Canvas dimensions & OKLab axis range */
    const PICKER_SIZE = 300;         // Width & height of the a,b picker (px)
    const AB_RANGE = 0.4;            // a,b axis extends from -0.4 to +0.4
    const SLIDER_HEIGHT = 28;        // Height of each slider (px)
    const CHROMA_MAX = 0.4;            // Maximum chroma value for the slider


    // ================================================================
    //  CANVAS SETUP
    //  If the browser supports Display P3 canvases (wide gamut), we use
    //  that color space so colors outside sRGB can be shown accurately
    //  on a wide-gamut monitor. Otherwise we fall back to sRGB.
    // ================================================================

    const abPickerCanvas = document.getElementById('ab-picker');
    const lightnessSliderCanvas = document.getElementById('lightness-slider');
    const chromaSliderCanvas = document.getElementById('chroma-slider');
    const hueSliderCanvas = document.getElementById('hue-slider');

    // Detect whether the display supports the P3 wide color gamut.
    // If it does, we use a 'display-p3' canvas so colors outside sRGB render accurately.
    const isDisplayP3Supported = window.matchMedia('(color-gamut: p3)').matches;
    const canvasColorSpace = isDisplayP3Supported ? 'display-p3' : 'srgb';
    const canvasOptions = { colorSpace: canvasColorSpace };
    const abPickerContext = abPickerCanvas.getContext('2d', canvasOptions);
    const lightnessContext = lightnessSliderCanvas.getContext('2d', canvasOptions);
    const chromaContext = chromaSliderCanvas.getContext('2d', canvasOptions);
    const hueContext = hueSliderCanvas.getContext('2d', canvasOptions);

    // Result mini a,b map canvas (150Ã—150)
    const RESULT_MAP_SIZE = 150;
    const resultABCanvas = document.getElementById('result-ab-map');
    const resultABContext = resultABCanvas.getContext('2d', canvasOptions);


    // ================================================================
    //  MATRIX UTILITIES
    //  3Ã—3 matrix operations used for ICC profile color space transforms.
    // ================================================================

    /** Multiply two 3Ã—3 matrices: result = A Ã— B */
    function mat3Multiply(A, B) {
      const R = [[0,0,0],[0,0,0],[0,0,0]];
      for (let i = 0; i < 3; i++)
        for (let j = 0; j < 3; j++)
          R[i][j] = A[i][0]*B[0][j] + A[i][1]*B[1][j] + A[i][2]*B[2][j];
      return R;
    }

    /** Apply a 3Ã—3 matrix to a 3-element vector: [r,g,b] */
    function mat3Apply(M, r, g, b) {
      return [
        M[0][0]*r + M[0][1]*g + M[0][2]*b,
        M[1][0]*r + M[1][1]*g + M[1][2]*b,
        M[2][0]*r + M[2][1]*g + M[2][2]*b,
      ];
    }

    /** Invert a 3Ã—3 matrix (Cramerâ€™s rule). Returns null if singular. */
    function mat3Invert(M) {
      const [a,b,c] = M[0], [d,e,f] = M[1], [g,h,k] = M[2];
      const det = a*(e*k-f*h) - b*(d*k-f*g) + c*(d*h-e*g);
      if (Math.abs(det) < 1e-15) return null;
      const inv = 1/det;
      return [
        [ (e*k-f*h)*inv, (c*h-b*k)*inv, (b*f-c*e)*inv],
        [ (f*g-d*k)*inv, (a*k-c*g)*inv, (c*d-a*f)*inv],
        [ (d*h-e*g)*inv, (b*g-a*h)*inv, (a*e-b*d)*inv],
      ];
    }


    // ================================================================
    //  WORKING COLOR SPACE
    //  Defines the current working color space used for gamut detection,
    //  hex value computation, and eyedropper interpretation.
    //  Can be Display P3, sRGB, or a custom ICC profile.
    // ================================================================

    // Well-known XYZ matrices (D65 white point)
    const XYZ_TO_LINEAR_SRGB = [
      [ 3.2409699419045226, -1.5373831775700939, -0.4986107602930034],
      [-0.9692436362808796,  1.8759675015077202,  0.04155505740717559],
      [ 0.05563007969699366,-0.20397696064091520, 1.0569715142428786],
    ];
    const LINEAR_SRGB_TO_XYZ = [
      [0.4123907992659595, 0.357584339383878,  0.1804807884018343],
      [0.21263900587151027,0.715168678767756,  0.07219231536073371],
      [0.01933081871559182,0.11919477979462598,0.9505321522496607],
    ];

    // Bradford chromatic adaptation D50 â†’ D65
    const BRADFORD_D50_TO_D65 = [
      [ 0.9555766, -0.0230393,  0.0631636],
      [-0.0282895,  1.0099416,  0.0210077],
      [ 0.0122982, -0.0204830,  1.3299098],
    ];

    /**
     * Create a working color space object.
     * @param {string} name - Display name
     * @param {number[][]} toSRGBMatrix - 3Ã—3 matrix: linear WCS â†’ linear sRGB
     * @param {number[][]} fromSRGBMatrix - 3Ã—3 matrix: linear sRGB â†’ linear WCS
     * @param {function} decode - gamma decode: encoded value â†’ linear
     * @param {function} encode - gamma encode: linear â†’ encoded value
     */
    function createWorkingCS(name, toSRGBMatrix, fromSRGBMatrix, decode, encode) {
      return {
        name,
        toLinearSRGB:   (r, g, b) => mat3Apply(toSRGBMatrix, r, g, b),
        fromLinearSRGB: (r, g, b) => mat3Apply(fromSRGBMatrix, r, g, b),
        decode,
        encode,
      };
    }

    /** Create an sRGB working color space (identity transform). */
    function createSRGBWorkingCS() {
      const I = [[1,0,0],[0,1,0],[0,0,1]];
      return createWorkingCS('sRGB', I, I, gammaToLinear, linearToGamma);
    }

    /** Create a Display P3 working color space. */
    function createP3WorkingCS() {
      // P3â†’sRGB = existing linearP3ToLinearSRGB, sRGBâ†’P3 = existing linearSRGBToLinearP3
      const p3ToSRGB = [
        [ 1.2249401762, -0.2249401762,  0.0],
        [-0.0420569549,  1.0420569549,  0.0],
        [-0.0196375546, -0.0786360236,  1.0982735782],
      ];
      const srgbToP3 = [
        [0.8224621209, 0.1775378791, 0.0],
        [0.0331941826, 0.9668058174, 0.0],
        [0.0170826307, 0.0723974407, 0.9105199286],
      ];
      // P3 uses the same sRGB transfer function
      return createWorkingCS('Display P3', p3ToSRGB, srgbToP3, gammaToLinear, linearToGamma);
    }

    /** Active working color space (default: P3 if supported, else sRGB) */
    let workingCS = isDisplayP3Supported ? createP3WorkingCS() : createSRGBWorkingCS();

    /** Update the UI to reflect the current working CS name. */
    function updateWorkingCSDisplay() {
      const el = document.getElementById('cs-name-display');
      el.textContent = workingCS.name;
      el.title = workingCS.name;
    }


    // ================================================================
    //  ICC PROFILE PARSER
    //  Reads matrix-based RGB ICC/ICM profiles to extract primaries
    //  and transfer curves, then builds a working color space from them.
    // ================================================================

    /**
     * Read a signed 15.16 fixed-point number from a DataView.
     */
    function readS15Fixed16(dv, offset) {
      const raw = dv.getInt32(offset, false); // big-endian
      return raw / 65536;
    }

    /**
     * Parse an ICC profile ArrayBuffer and return a working CS object.
     * Supports matrix-based RGB profiles (rXYZ/gXYZ/bXYZ + TRC tags).
     * @throws {Error} if the profile is unsupported
     */
    function parseICCProfile(buffer) {
      const dv = new DataView(buffer);
      const bytes = new Uint8Array(buffer);

      // Read tag table
      const tagCount = dv.getUint32(128, false);
      const tags = {};
      for (let i = 0; i < tagCount; i++) {
        const base = 132 + i * 12;
        const sig = String.fromCharCode(bytes[base], bytes[base+1], bytes[base+2], bytes[base+3]);
        tags[sig] = {
          offset: dv.getUint32(base + 4, false),
          size:   dv.getUint32(base + 8, false),
        };
      }

      // Extract profile description for the name
      let profileName = 'Custom CS';
      if (tags['desc']) {
        const descOff = tags['desc'].offset;
        const descType = String.fromCharCode(
          bytes[descOff], bytes[descOff+1], bytes[descOff+2], bytes[descOff+3]
        );
        if (descType === 'desc') {
          // ICC v2 'desc' type: 4 type + 4 reserved + 4 length + ASCII string
          const strLen = dv.getUint32(descOff + 8, false);
          const strBytes = bytes.slice(descOff + 12, descOff + 12 + strLen - 1);
          profileName = new TextDecoder('ascii').decode(strBytes).trim() || 'Custom CS';
        } else if (descType === 'mluc') {
          // ICC v4 'mluc' type: multi-localized Unicode
          const recCount = dv.getUint32(descOff + 8, false);
          if (recCount > 0) {
            const recLen   = dv.getUint32(descOff + 16, false);
            const recOff   = dv.getUint32(descOff + 20, false);
            const strData  = new Uint16Array(recLen / 2);
            for (let i = 0; i < strData.length; i++) {
              strData[i] = dv.getUint16(descOff + recOff + i * 2, false);
            }
            profileName = String.fromCharCode(...strData).replace(/\0/g, '').trim() || 'Custom CS';
          }
        }
      }

      // We need rXYZ, gXYZ, bXYZ for the 3Ã—3 matrix
      if (!tags['rXYZ'] || !tags['gXYZ'] || !tags['bXYZ']) {
        throw new Error('Not a matrix-based RGB profile (missing XYZ tags)');
      }

      // Read XYZ values (each tag: 4 type + 4 reserved + 12 XYZ data)
      function readXYZTag(tag) {
        const o = tag.offset + 8; // skip type signature + reserved
        return [
          readS15Fixed16(dv, o),
          readS15Fixed16(dv, o + 4),
          readS15Fixed16(dv, o + 8),
        ];
      }

      const rXYZ = readXYZTag(tags['rXYZ']);
      const gXYZ = readXYZTag(tags['gXYZ']);
      const bXYZ = readXYZTag(tags['bXYZ']);

      // Build customâ†’XYZ matrix (D50 PCS, columns = primaries)
      const customToXYZ_D50 = [
        [rXYZ[0], gXYZ[0], bXYZ[0]],
        [rXYZ[1], gXYZ[1], bXYZ[1]],
        [rXYZ[2], gXYZ[2], bXYZ[2]],
      ];

      // Adapt from D50 to D65, then convert to linear sRGB
      const customToXYZ_D65 = mat3Multiply(BRADFORD_D50_TO_D65, customToXYZ_D50);
      const customToLinearSRGB = mat3Multiply(XYZ_TO_LINEAR_SRGB, customToXYZ_D65);
      const linearSRGBToCustom = mat3Invert(customToLinearSRGB);
      if (!linearSRGBToCustom) throw new Error('Singular matrix in ICC profile');

      // Parse TRC (transfer response curve) tags
      function parseTRC(tag) {
        const o = tag.offset;
        const type = String.fromCharCode(bytes[o], bytes[o+1], bytes[o+2], bytes[o+3]);

        if (type === 'curv') {
          const count = dv.getUint32(o + 8, false);
          if (count === 0) {
            // Linear
            return { decode: v => v, encode: v => v };
          } else if (count === 1) {
            // Simple gamma: u8Fixed8Number
            const gamma = dv.getUint16(o + 12, false) / 256;
            return {
              decode: v => Math.pow(Math.max(0, v), gamma),
              encode: v => Math.pow(Math.max(0, v), 1 / gamma),
            };
          } else {
            // Table-based curve: build forward + inverse LUT
            const table = new Float64Array(count);
            for (let i = 0; i < count; i++) {
              table[i] = dv.getUint16(o + 12 + i * 2, false) / 65535;
            }
            const invSize = 4096;
            const invTable = new Float64Array(invSize);
            let ti = 0;
            for (let i = 0; i < invSize; i++) {
              const target = i / (invSize - 1);
              while (ti < count - 2 && table[ti + 1] < target) ti++;
              const t0 = table[ti], t1 = table[Math.min(ti + 1, count - 1)];
              const frac = t1 > t0 ? (target - t0) / (t1 - t0) : 0;
              invTable[i] = (ti + frac) / (count - 1);
            }
            return {
              decode: v => {
                const x = Math.max(0, Math.min(1, v)) * (count - 1);
                const lo = Math.floor(x), hi = Math.min(lo + 1, count - 1);
                return table[lo] + (table[hi] - table[lo]) * (x - lo);
              },
              encode: v => {
                const x = Math.max(0, Math.min(1, v)) * (invSize - 1);
                const lo = Math.floor(x), hi = Math.min(lo + 1, invSize - 1);
                return invTable[lo] + (invTable[hi] - invTable[lo]) * (x - lo);
              },
            };
          }
        }

        if (type === 'para') {
          const funcType = dv.getUint16(o + 8, false);
          const p = (idx) => readS15Fixed16(dv, o + 12 + idx * 4);
          if (funcType === 0) {
            const g = p(0);
            return {
              decode: v => Math.pow(Math.max(0, v), g),
              encode: v => Math.pow(Math.max(0, v), 1/g),
            };
          } else if (funcType === 3) {
            // Y = (aX+b)^g if X>=d, else cX   (sRGB-like)
            const g = p(0), a = p(1), b = p(2), c = p(3), d = p(4);
            return {
              decode: v => v >= d ? Math.pow(a * v + b, g) : c * v,
              encode: v => {
                const cutoff = c * d;
                if (v <= cutoff && c !== 0) return v / c;
                return (Math.pow(Math.max(0, v), 1/g) - b) / a;
              },
            };
          } else if (funcType === 4) {
            const g = p(0), a = p(1), b = p(2), c = p(3), d = p(4), e = p(5), f = p(6);
            return {
              decode: v => v >= d ? Math.pow(a * v + b, g) + e : c * v + f,
              encode: v => {
                const cutoff = c * d + f;
                if (v <= cutoff && c !== 0) return (v - f) / c;
                return (Math.pow(Math.max(0, v - e), 1/g) - b) / a;
              },
            };
          }
          // Fallback for other parametric types: treat as gamma-only
          const g = p(0);
          return {
            decode: v => Math.pow(Math.max(0, v), g),
            encode: v => Math.pow(Math.max(0, v), 1/g),
          };
        }

        // Unknown TRC type â†’ assume sRGB
        return { decode: gammaToLinear, encode: linearToGamma };
      }

      // Parse the three TRC channels
      const rTRC = tags['rTRC'] ? parseTRC(tags['rTRC']) : { decode: gammaToLinear, encode: linearToGamma };
      const gTRC = tags['gTRC'] ? parseTRC(tags['gTRC']) : { decode: gammaToLinear, encode: linearToGamma };
      const bTRC = tags['bTRC'] ? parseTRC(tags['bTRC']) : { decode: gammaToLinear, encode: linearToGamma };

      // Build per-channel decode/encode (handles profiles with different per-channel curves)
      function decode(v, ch) {
        if (ch === 0) return rTRC.decode(v);
        if (ch === 1) return gTRC.decode(v);
        return bTRC.decode(v);
      }
      function encode(v, ch) {
        if (ch === 0) return rTRC.encode(v);
        if (ch === 1) return gTRC.encode(v);
        return bTRC.encode(v);
      }

      return {
        name: profileName,
        toLinearSRGB:   (r, g, b) => mat3Apply(customToLinearSRGB, r, g, b),
        fromLinearSRGB: (r, g, b) => mat3Apply(linearSRGBToCustom, r, g, b),
        decode: (v, ch) => decode(v, ch),
        encode: (v, ch) => encode(v, ch),
        perChannelTRC: true,
      };
    }

    /**
     * Handle ICC file import from the file input.
     */
    async function handleICCImport(input) {
      if (!input.files || !input.files[0]) return;
      try {
        const buffer = await input.files[0].arrayBuffer();
        workingCS = parseICCProfile(buffer);
        // Cache the raw profile bytes for persistence
        const bytes = new Uint8Array(buffer);
        let binary = '';
        for (let i = 0; i < bytes.length; i++) binary += String.fromCharCode(bytes[i]);
        iccProfileBase64 = btoa(binary);
        updateWorkingCSDisplay();
        renderAll();
        scheduleSave();
      } catch (err) {
        alert('Failed to load ICC profile:\n' + err.message);
      }
      input.value = ''; // allow re-importing the same file
    }

    /**
     * Reset working CS to the default (P3 if supported, else sRGB).
     */
    function resetWorkingCS() {
      workingCS = isDisplayP3Supported ? createP3WorkingCS() : createSRGBWorkingCS();
      iccProfileBase64 = null;
      updateWorkingCSDisplay();
      renderAll();
      scheduleSave();
    }


    // ================================================================
    //  AUTO-SAVE / RESTORE
    //  Persists application state to localStorage with a debounced
    //  save (500 ms), so rapid interactions don't cause lag.
    //  Restores state on next launch before the first render.
    // ================================================================

    const STORAGE_KEY = 'oklab-color-picker-state';
    const SAVE_HISTORY_CAP = 50; // Keep last N entries per stack when saving
    let saveTimer = null;

    /** Schedule a debounced save (coalesces rapid changes). */
    function scheduleSave() {
      if (saveTimer) clearTimeout(saveTimer);
      saveTimer = setTimeout(saveState, 500);
    }

    /** Serialize current state to localStorage. */
    function saveState() {
      saveTimer = null;
      try {
        const capHistory = (h) => {
          const start = Math.max(0, h.entries.length - SAVE_HISTORY_CAP);
          const entries = h.entries.slice(start);
          const pos = Math.max(0, h.pos - start);
          return { entries, pos };
        };
        const state = {
          // Current picker color
          currentL, currentA, currentB,
          // Lighting Lab
          albedoL, albedoA, albedoB,
          lightL, lightA, lightB,
          lightIntensity,
          editTarget,
          isLightingOpen,
          // History (capped)
          historyMain:   capHistory(historyMain),
          historyAlbedo: capHistory(historyAlbedo),
          historyLight:  capHistory(historyLight),
          // Working color space
          iccProfileBase64,
        };
        localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
      } catch (_) { /* quota exceeded or other â€” silently skip */ }
    }

    /**
     * Restore saved state from localStorage.
     * Returns true if state was restored, false otherwise.
     */
    function restoreState() {
      try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) return false;
        const s = JSON.parse(raw);

        // Picker color
        if (typeof s.currentL === 'number') currentL = s.currentL;
        if (typeof s.currentA === 'number') currentA = s.currentA;
        if (typeof s.currentB === 'number') currentB = s.currentB;

        // Lighting Lab colors
        if (typeof s.albedoL === 'number') { albedoL = s.albedoL; albedoA = s.albedoA; albedoB = s.albedoB; }
        if (typeof s.lightL  === 'number') { lightL  = s.lightL;  lightA  = s.lightA;  lightB  = s.lightB;  }
        if (typeof s.lightIntensity === 'number') lightIntensity = s.lightIntensity;
        if (typeof s.editTarget === 'string') editTarget = s.editTarget;

        // History stacks
        const loadHistory = (target, src) => {
          if (src && Array.isArray(src.entries) && src.entries.length > 0) {
            target.entries = src.entries;
            target.pos = Math.min(src.pos || 0, src.entries.length - 1);
          }
        };
        loadHistory(historyMain,   s.historyMain);
        loadHistory(historyAlbedo, s.historyAlbedo);
        loadHistory(historyLight,  s.historyLight);

        // ICC profile
        if (s.iccProfileBase64) {
          try {
            const binary = atob(s.iccProfileBase64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            workingCS = parseICCProfile(bytes.buffer);
            iccProfileBase64 = s.iccProfileBase64;
          } catch (_) { /* profile failed to parse â€” keep default CS */ }
        }

        // Lighting Lab open state
        if (s.isLightingOpen) {
          isLightingOpen = true;
          document.getElementById('lighting-panel').classList.add('open');
          document.getElementById('lighting-toggle-button').classList.add('active');
          // Restore tab selection UI directly (avoid triggering scheduleSave)
          document.getElementById('tab-albedo').classList.toggle('tab-active', editTarget === 'albedo');
          document.getElementById('tab-light').classList.toggle('tab-active', editTarget === 'light');
          document.getElementById('swatch-albedo').classList.toggle('selected', editTarget === 'albedo');
          document.getElementById('swatch-light').classList.toggle('selected', editTarget === 'light');
          syncPickerToEditTarget();
        }

        return true;
      } catch (_) { return false; }
    }


    // ================================================================
    //  GAMUT HELPERS
    //  Functions for checking and clamping colors to the working gamut.
    //  Uses the active working color space for gamut detection.
    // ================================================================

    /**
     * Check whether an OKLab color falls within the working color space gamut.
     */
    function isInWorkingGamut(L, a, b) {
      const [linearR, linearG, linearB] = oklabToLinearSRGB(L, a, b);
      const [wr, wg, wb] = workingCS.fromLinearSRGB(linearR, linearG, linearB);
      return isInGamut(wr, wg, wb);
    }

    /**
     * Binary-search for the maximum chroma that keeps the color in the
     * working gamut at a given lightness and hue angle.
     * @returns {number} Maximum in-gamut chroma
     */
    function findMaxInGamutChroma(L, hueDegrees, maxSearch = CHROMA_MAX) {
      const [aHi, bHi] = oklchToOklab(maxSearch, hueDegrees);
      if (isInWorkingGamut(L, aHi, bHi)) return maxSearch;
      let lo = 0, hi = maxSearch;
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        const [a, b] = oklchToOklab(mid, hueDegrees);
        if (isInWorkingGamut(L, a, b)) { lo = mid; } else { hi = mid; }
      }
      return lo;
    }

    /**
     * Clamp an OKLab color to the working gamut by reducing chroma
     * while preserving lightness and hue.
     * @returns {[number, number]} Clamped [a, b] values
     */
    function clampToWorkingGamut(L, a, b) {
      if (isInWorkingGamut(L, a, b)) return [a, b];
      const [chroma, hue] = oklabToOklch(a, b);
      const maxChroma = findMaxInGamutChroma(L, hue, chroma);
      return oklchToOklab(maxChroma, hue);
    }


    // ================================================================
    //  RENDERING: a,b PICKER
    //  Draws a 300Ã—300 image where each pixel represents an OKLab color
    //  at the current lightness (L). The x-axis maps to 'a' (greenâ†’red),
    //  and the y-axis maps to 'b' (blueâ†’yellow, top = +b).
    // ================================================================

    /** Cached ImageData for the a,b picker background */
    let abPickerImageData = null;

    /**
     * Compute the pixel colors for every (a, b) combination at the
     * current lightness value and store them in abPickerImageData.
     */
    function renderABPickerColors() {
      abPickerImageData = abPickerContext.createImageData(PICKER_SIZE, PICKER_SIZE);
      const pixels = abPickerImageData.data;
      const step = (2 * AB_RANGE) / (PICKER_SIZE - 1);

      for (let y = 0; y < PICKER_SIZE; y++) {
        // Top of canvas = +AB_RANGE (positive b), bottom = -AB_RANGE
        const bValue = AB_RANGE - y * step;

        for (let x = 0; x < PICKER_SIZE; x++) {
          // Left of canvas = -AB_RANGE (negative a), right = +AB_RANGE
          const aValue = -AB_RANGE + x * step;

          // Convert this OKLab color to linear sRGB
          const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, aValue, bValue);

          // Calculate the pixel offset in the ImageData buffer (4 bytes per pixel: RGBA)
          const pixelIndex = (y * PICKER_SIZE + x) * 4;

          let byteR, byteG, byteB, inGamut;
          inGamut = isInWorkingGamut(currentL, aValue, bValue);
          if (isDisplayP3Supported) {
            const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
            byteR = linearToColorByte(p3R);
            byteG = linearToColorByte(p3G);
            byteB = linearToColorByte(p3B);
          } else {
            byteR = linearToColorByte(linearR);
            byteG = linearToColorByte(linearG);
            byteB = linearToColorByte(linearB);
          }

          // Darken out-of-gamut pixels with diagonal stripe pattern
          if (!inGamut) {
            byteR = Math.round(byteR * 0.15);
            byteG = Math.round(byteG * 0.15);
            byteB = Math.round(byteB * 0.15);
            if ((x + y) % 6 < 1) {
              byteR = Math.min(255, byteR + 35);
              byteG = Math.min(255, byteG + 35);
              byteB = Math.min(255, byteB + 35);
            }
          }

          pixels[pixelIndex]     = byteR;
          pixels[pixelIndex + 1] = byteG;
          pixels[pixelIndex + 2] = byteB;
          pixels[pixelIndex + 3] = 255; // Fully opaque
        }
      }
    }

    /**
     * Draw the a,b picker: blit the cached color image, then draw
     * a crosshair circle at the currently selected (a, b) position.
     */
    function drawABPicker() {
      if (!abPickerImageData) return;

      // Draw the pre-computed color field
      abPickerContext.putImageData(abPickerImageData, 0, 0);

      // Convert current (a, b) values to canvas pixel coordinates
      const cursorX = ((currentA + AB_RANGE) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);
      const cursorY = ((AB_RANGE - currentB) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);

      // Use contrasting colors for the crosshair depending on lightness
      const isDark = currentL > 0.5;

      // Inner ring (strong contrast)
      abPickerContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      abPickerContext.lineWidth = 2.5;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 7, 0, 2 * Math.PI);
      abPickerContext.stroke();

      // Outer ring (subtle halo for visibility)
      abPickerContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      abPickerContext.lineWidth = 1;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 9, 0, 2 * Math.PI);
      abPickerContext.stroke();
    }


    // ================================================================
    //  RENDERING: LIGHTNESS SLIDER
    //  A horizontal bar where each pixel column represents a different
    //  lightness (L) value at the current (a, b). Left = 0, right = 1.
    // ================================================================

    /** Cached ImageData for the lightness slider background */
    let lightnessImageData = null;

    /**
     * Compute the pixel colors for the lightness slider at the
     * current (a, b) values.
     */
    function renderLightnessSliderColors() {
      lightnessImageData = lightnessContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = lightnessImageData.data;

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to lightness value [0, 1]
        const lightnessValue = x / (PICKER_SIZE - 1);

        // Convert this OKLab color to linear sRGB
        const [linearR, linearG, linearB] = oklabToLinearSRGB(lightnessValue, currentA, currentB);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        inGamut = isInWorkingGamut(lightnessValue, currentA, currentB);
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the lightness slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected L value.
     */
    function drawLightnessSlider() {
      if (!lightnessImageData) return;

      // Draw the pre-computed gradient
      lightnessContext.putImageData(lightnessImageData, 0, 0);

      // Convert current L to a pixel x-coordinate
      const indicatorX = currentL * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      lightnessContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      lightnessContext.lineWidth = 3;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX, 0);
      lightnessContext.lineTo(indicatorX, SLIDER_HEIGHT);
      lightnessContext.stroke();

      // Flanking lines for contrast
      lightnessContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      lightnessContext.lineWidth = 1;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX - 2, 0);
      lightnessContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      lightnessContext.moveTo(indicatorX + 2, 0);
      lightnessContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      lightnessContext.stroke();
    }


    // ================================================================
    //  RENDERING: CHROMA SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  chroma (C) value, keeping the current L and hue constant.
    //  Left = 0, right = CHROMA_MAX.
    // ================================================================

    /** Cached ImageData for the chroma slider background */
    let chromaImageData = null;

    /**
     * Compute the pixel colors for the chroma slider at the
     * current lightness and hue.
     */
    function renderChromaSliderColors() {
      chromaImageData = chromaContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = chromaImageData.data;
      const [, currentHue] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to chroma value [0, CHROMA_MAX]
        const chromaValue = (x / (PICKER_SIZE - 1)) * CHROMA_MAX;

        // Convert OKLCH â†’ OKLab â†’ linear sRGB
        const [a, b] = oklchToOklab(chromaValue, currentHue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        inGamut = isInWorkingGamut(currentL, a, b);
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the chroma slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected chroma.
     */
    function drawChromaSlider() {
      if (!chromaImageData) return;

      chromaContext.putImageData(chromaImageData, 0, 0);

      // Compute current chroma and map to pixel position
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentChroma / CHROMA_MAX) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      chromaContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      chromaContext.lineWidth = 3;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX, 0);
      chromaContext.lineTo(indicatorX, SLIDER_HEIGHT);
      chromaContext.stroke();

      // Flanking lines for contrast
      chromaContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      chromaContext.lineWidth = 1;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX - 2, 0);
      chromaContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      chromaContext.moveTo(indicatorX + 2, 0);
      chromaContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      chromaContext.stroke();
    }


    // ================================================================
    //  RENDERING: HUE SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  hue angle, keeping the current L and chroma constant.
    //  Left = 0Â°, right = 360Â°.
    // ================================================================

    /** Cached ImageData for the hue slider background */
    let hueImageData = null;

    /**
     * Compute the pixel colors for the hue slider at the
     * current lightness and chroma.
     */
    function renderHueSliderColors() {
      hueImageData = hueContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = hueImageData.data;
      const [currentChroma] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to hue value [0, 360)
        const hueValue = (x / (PICKER_SIZE - 1)) * 360;

        // Convert OKLCH â†’ OKLab â†’ linear sRGB
        const [a, b] = oklchToOklab(currentChroma, hueValue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        inGamut = isInWorkingGamut(currentL, a, b);
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the hue slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected hue.
     */
    function drawHueSlider() {
      if (!hueImageData) return;

      hueContext.putImageData(hueImageData, 0, 0);

      // Compute current hue and map to pixel position
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentHue / 360) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      hueContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      hueContext.lineWidth = 3;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX, 0);
      hueContext.lineTo(indicatorX, SLIDER_HEIGHT);
      hueContext.stroke();

      // Flanking lines for contrast
      hueContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      hueContext.lineWidth = 1;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX - 2, 0);
      hueContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      hueContext.moveTo(indicatorX + 2, 0);
      hueContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      hueContext.stroke();
    }


    // ================================================================
    //  INFO PANEL
    //  Updates the color preview swatch, OKLab/OKLCH readout, hex codes,
    //  and gamut indicators.
    // ================================================================

    function updateInfoPanel() {
      // Convert current OKLab â†’ linear sRGB
      const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, currentA, currentB);

      // Check sRGB gamut and compute hex
      const srgbInGamut = isInGamut(linearR, linearG, linearB);
      const srgbHex = rgbToHex(
        linearToGamma(linearR),
        linearToGamma(linearG),
        linearToGamma(linearB)
      );

      // Convert to Display P3, check gamut, compute hex
      const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
      const p3InGamut = isInGamut(p3R, p3G, p3B);
      const p3Hex = rgbToHex(
        linearToGamma(p3R),
        linearToGamma(p3G),
        linearToGamma(p3B)
      );

      // Convert to working CS, check gamut, compute hex
      const [wcR, wcG, wcB] = workingCS.fromLinearSRGB(linearR, linearG, linearB);
      const workingInGamut = isInGamut(wcR, wcG, wcB);
      let workingHex;
      if (workingCS.perChannelTRC) {
        workingHex = rgbToHex(
          workingCS.encode(wcR, 0),
          workingCS.encode(wcG, 1),
          workingCS.encode(wcB, 2)
        );
      } else {
        workingHex = rgbToHex(
          workingCS.encode(wcR),
          workingCS.encode(wcG),
          workingCS.encode(wcB)
        );
      }

      // Compute OKLCH values for display
      const [currentChroma, currentHue] = oklabToOklch(currentA, currentB);

      // Update the OKLab + OKLCH numeric readout
      document.getElementById('oklab-values').innerHTML =
        `L: <b>${currentL.toFixed(3)}</b>&ensp;` +
        `a: <b>${currentA.toFixed(3)}</b>&ensp;` +
        `b: <b>${currentB.toFixed(3)}</b><br>` +
        `C: <b>${currentChroma.toFixed(3)}</b>&ensp;` +
        `h: <b>${currentHue.toFixed(1)}Â°</b>`;

      // Update the preview swatch using native CSS oklab() for correct rendering
      document.getElementById('color-preview').style.background =
        `oklab(${currentL} ${currentA} ${currentB})`;

      // Update sRGB hex and gamut indicator
      document.getElementById('srgb-hex').textContent = srgbHex;
      document.getElementById('srgb-gamut-indicator').innerHTML = srgbInGamut
        ? '<span class="in-gamut" title="In sRGB gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of sRGB gamut">âœ— out of gamut</span>';

      // Update Display P3 hex and gamut indicator
      document.getElementById('display-p3-hex').textContent = p3Hex;
      document.getElementById('display-p3-gamut-indicator').innerHTML = p3InGamut
        ? '<span class="in-gamut" title="In Display P3 gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of Display P3 gamut">âœ— out of gamut</span>';

      // Update working CS hex and gamut indicator (only shown for custom profiles)
      const isCustomCS = workingCS.name !== 'Display P3' && workingCS.name !== 'sRGB';
      document.getElementById('working-cs-row').style.display = isCustomCS ? '' : 'none';
      if (isCustomCS) {
        document.getElementById('working-hex').textContent = workingHex;
        document.getElementById('working-gamut-indicator').innerHTML = workingInGamut
          ? '<span class="in-gamut" title="In ' + workingCS.name + ' gamut">âœ“</span>'
          : '<span class="out-of-gamut" title="Out of ' + workingCS.name + ' gamut">âœ— out of gamut</span>';
        document.getElementById('working-cs-hex-label').textContent = workingCS.name.length > 10
          ? workingCS.name.slice(0, 9) + 'â€¦:'
          : workingCS.name + ':';
      }

      // Update the raw CSS oklab() value
      document.getElementById('css-oklab-value').textContent =
        `oklab(${currentL.toFixed(3)} ${currentA.toFixed(3)} ${currentB.toFixed(3)})`;
    }


    // ================================================================
    //  LIGHTING LAB
    //  Computes result = albedo Ã— light in linear sRGB space.
    //  Shows the result on a read-only mini a,b map and info readout.
    // ================================================================

    /**
     * Compute the lit color: result = albedo Ã— light (component-wise
     * multiply in linear sRGB). Returns OKLab [L, a, b].
     */
    function computeLitColor() {
      const [albR, albG, albB] = oklabToLinearSRGB(albedoL, albedoA, albedoB);
      const [litR, litG, litB] = oklabToLinearSRGB(lightL, lightA, lightB);

      // Component-wise multiplication in linear light, scaled by intensity
      const resultR = albR * litR * lightIntensity;
      const resultG = albG * litG * lightIntensity;
      const resultB = albB * litB * lightIntensity;

      return linearSRGBToOKLab(resultR, resultG, resultB);
    }

    /** Cached ImageData for the result mini a,b map */
    let resultABImageData = null;

    /**
     * Render the result mini a,b map. Shows the color field at the
     * result's lightness, with a marker at the result (a, b).
     */
    function renderResultABMap() {
      const [resL, resA, resB] = computeLitColor();

      resultABImageData = resultABContext.createImageData(RESULT_MAP_SIZE, RESULT_MAP_SIZE);
      const pixels = resultABImageData.data;
      const step = (2 * AB_RANGE) / (RESULT_MAP_SIZE - 1);

      for (let y = 0; y < RESULT_MAP_SIZE; y++) {
        const bVal = AB_RANGE - y * step;
        for (let x = 0; x < RESULT_MAP_SIZE; x++) {
          const aVal = -AB_RANGE + x * step;
          const [linR, linG, linB] = oklabToLinearSRGB(resL, aVal, bVal);
          const idx = (y * RESULT_MAP_SIZE + x) * 4;

          let bR, bG, bB, inGamut;
          inGamut = isInWorkingGamut(resL, aVal, bVal);
          if (isDisplayP3Supported) {
            const [p3R, p3G, p3B] = linearSRGBToLinearP3(linR, linG, linB);
            bR = linearToColorByte(p3R);
            bG = linearToColorByte(p3G);
            bB = linearToColorByte(p3B);
          } else {
            bR = linearToColorByte(linR);
            bG = linearToColorByte(linG);
            bB = linearToColorByte(linB);
          }

          if (!inGamut) {
            bR = Math.round(bR * 0.15);
            bG = Math.round(bG * 0.15);
            bB = Math.round(bB * 0.15);
            if ((x + y) % 6 < 1) {
              bR = Math.min(255, bR + 35);
              bG = Math.min(255, bG + 35);
              bB = Math.min(255, bB + 35);
            }
          }

          pixels[idx]     = bR;
          pixels[idx + 1] = bG;
          pixels[idx + 2] = bB;
          pixels[idx + 3] = 255;
        }
      }

      resultABContext.putImageData(resultABImageData, 0, 0);

      // Draw crosshair at the result (a, b) position
      const cx = ((resA + AB_RANGE) / (2 * AB_RANGE)) * (RESULT_MAP_SIZE - 1);
      const cy = ((AB_RANGE - resB) / (2 * AB_RANGE)) * (RESULT_MAP_SIZE - 1);
      const isDark = resL > 0.5;

      resultABContext.strokeStyle = isDark ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.85)';
      resultABContext.lineWidth = 2;
      resultABContext.beginPath();
      resultABContext.arc(cx, cy, 5, 0, 2 * Math.PI);
      resultABContext.stroke();

      resultABContext.strokeStyle = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
      resultABContext.lineWidth = 1;
      resultABContext.beginPath();
      resultABContext.arc(cx, cy, 7, 0, 2 * Math.PI);
      resultABContext.stroke();
    }

    /**
     * Update the lighting panel swatches and result info.
     */
    function updateLightingPanel() {
      if (!isLightingOpen) return;

      // Update swatches using CSS oklab()
      document.getElementById('swatch-albedo').style.background =
        `oklab(${albedoL} ${albedoA} ${albedoB})`;
      document.getElementById('swatch-light').style.background = (() => {
        const [lr, lg, lb] = oklabToLinearSRGB(lightL, lightA, lightB);
        const [iL, iA, iB] = linearSRGBToOKLab(lr * lightIntensity, lg * lightIntensity, lb * lightIntensity);
        return `oklab(${iL} ${iA} ${iB})`;
      })();

      // Update intensity slider UI
      const pct = Math.min(lightIntensity / INTENSITY_MAX, 1) * 100;
      document.getElementById('intensity-fill').style.width = pct + '%';
      document.getElementById('intensity-thumb').style.left = pct + '%';
      document.getElementById('intensity-value').textContent = lightIntensity.toFixed(2);

      const [resL, resA, resB] = computeLitColor();
      document.getElementById('swatch-result').style.background =
        `oklab(${resL} ${resA} ${resB})`;

      // Result numeric readout
      const [resChroma, resHue] = oklabToOklch(resA, resB);
      document.getElementById('lighting-result-values').innerHTML =
        `<span class="label">L:</span> <b>${resL.toFixed(3)}</b>&ensp;` +
        `<span class="label">a:</span> <b>${resA.toFixed(3)}</b>&ensp;` +
        `<span class="label">b:</span> <b>${resB.toFixed(3)}</b><br>` +
        `<span class="label">C:</span> <b>${resChroma.toFixed(3)}</b>&ensp;` +
        `<span class="label">h:</span> <b>${resHue.toFixed(1)}Â°</b>`;

      // Result hex codes: sRGB, Display P3, Working CS
      const [linR, linG, linB] = oklabToLinearSRGB(resL, resA, resB);

      // sRGB
      const srgbOk = isInGamut(linR, linG, linB);
      const srgbHex = rgbToHex(linearToGamma(linR), linearToGamma(linG), linearToGamma(linB));
      document.getElementById('result-srgb-hex').textContent = srgbHex;
      document.getElementById('result-srgb-gamut').innerHTML = srgbOk
        ? '<span class="in-gamut" title="In sRGB gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of sRGB gamut">âœ—</span>';

      // Display P3
      const [p3R, p3G, p3B] = linearSRGBToLinearP3(linR, linG, linB);
      const p3Ok = isInGamut(p3R, p3G, p3B);
      const p3Hex = rgbToHex(linearToGamma(p3R), linearToGamma(p3G), linearToGamma(p3B));
      document.getElementById('result-p3-hex').textContent = p3Hex;
      document.getElementById('result-p3-gamut').innerHTML = p3Ok
        ? '<span class="in-gamut" title="In Display P3 gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of Display P3 gamut">âœ—</span>';

      // Working CS (only shown for custom ICC profiles)
      const isCustomCS = workingCS.name !== 'Display P3' && workingCS.name !== 'sRGB';
      document.getElementById('result-wcs-row').style.display = isCustomCS ? '' : 'none';
      if (isCustomCS) {
        const [wcR, wcG, wcB] = workingCS.fromLinearSRGB(linR, linG, linB);
        const wcOk = isInGamut(wcR, wcG, wcB);
        let wcHex;
        if (workingCS.perChannelTRC) {
          wcHex = rgbToHex(workingCS.encode(wcR, 0), workingCS.encode(wcG, 1), workingCS.encode(wcB, 2));
        } else {
          wcHex = rgbToHex(workingCS.encode(wcR), workingCS.encode(wcG), workingCS.encode(wcB));
        }
        document.getElementById('result-wcs-hex').textContent = wcHex;
        document.getElementById('result-wcs-gamut').innerHTML = wcOk
          ? '<span class="in-gamut" title="In ' + workingCS.name + ' gamut">âœ“</span>'
          : '<span class="out-of-gamut" title="Out of ' + workingCS.name + ' gamut">âœ—</span>';
        document.getElementById('result-wcs-label').textContent = workingCS.name.length > 10
          ? workingCS.name.slice(0, 9) + 'â€¦:' : workingCS.name + ':';
      }

      document.getElementById('result-css-value').textContent =
        `oklab(${resL.toFixed(3)} ${resA.toFixed(3)} ${resB.toFixed(3)})`;

      // Render the result mini a,b map
      renderResultABMap();
    }


    // ================================================================
    //  RENDER ORCHESTRATION
    //  Different interactions require recomputing different parts:
    //  - renderAll: recompute everything (initial load, color pick)
    //  - onABChanged: a or b changed â†’ recompute L slider, redraw both
    //  - onLightnessChanged: L changed â†’ recompute a,b field, redraw both
    // ================================================================

    /** Helper: redraw all slider indicators + info (no pixel recomputation) */
    function drawAllSliders() {
      drawLightnessSlider();
      drawChromaSlider();
      drawHueSlider();
    }

    /** Helper: recompute all slider gradients */
    function renderAllSliderColors() {
      renderLightnessSliderColors();
      renderChromaSliderColors();
      renderHueSliderColors();
    }

    function renderAll() {
      syncPickerToEditTarget();
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      updateLightingPanel();
    }

    function onABChanged() {
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onLightnessChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onChromaChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onHueChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    /**
     * Write the current picker state (currentL/A/B) into the active
     * edit target (albedo or light). Only acts when Lighting Lab is open.
     */
    function writePickerToEditTarget() {
      if (!isLightingOpen) return;
      if (editTarget === 'albedo') {
        albedoL = currentL;
        albedoA = currentA;
        albedoB = currentB;
      } else {
        lightL = currentL;
        lightA = currentA;
        lightB = currentB;
      }
    }

    /**
     * Load the active edit target's color into the picker state
     * and re-render.
     */
    function syncPickerToEditTarget() {
      if (!isLightingOpen) return;
      if (editTarget === 'albedo') {
        currentL = albedoL;
        currentA = albedoA;
        currentB = albedoB;
      } else {
        currentL = lightL;
        currentA = lightA;
        currentB = lightB;
      }
    }

    /**
     * Switch the main picker to edit albedo or light color.
     */
    function setEditTarget(target) {
      editTarget = target;
      document.getElementById('tab-albedo').classList.toggle('tab-active', target === 'albedo');
      document.getElementById('tab-light').classList.toggle('tab-active', target === 'light');
      document.getElementById('swatch-albedo').classList.toggle('selected', target === 'albedo');
      document.getElementById('swatch-light').classList.toggle('selected', target === 'light');
      syncPickerToEditTarget();
      renderAll();
      scheduleSave();
    }
    function toggleLightingPanel() {
      isLightingOpen = !isLightingOpen;
      document.getElementById('lighting-panel').classList.toggle('open', isLightingOpen);
      document.getElementById('lighting-toggle-button').classList.toggle('active', isLightingOpen);
      if (isLightingOpen) {
        // Snapshot current picker color as albedo
        albedoL = currentL;
        albedoA = currentA;
        albedoB = currentB;
        editTarget = 'albedo';
        document.getElementById('tab-albedo').classList.add('tab-active');
        document.getElementById('tab-light').classList.remove('tab-active');
        document.getElementById('swatch-albedo').classList.add('selected');
        document.getElementById('swatch-light').classList.remove('selected');
        updateLightingPanel();
      }
      scheduleSave();
    }
    //  Handles click-and-drag on both the a,b picker and the L slider.
    //  Uses requestAnimationFrame to throttle redraws during drag.
    // ================================================================

    let isDraggingAB = false;
    let isDraggingLightness = false;
    let isDraggingChroma = false;
    let isDraggingHue = false;
    let isDraggingIntensity = false;
    let isAnimationFramePending = false;

    /**
     * Read pointer position over the a,b picker canvas and update
     * currentA and currentB accordingly.
     */
    function updateABFromPointer(event) {
      const rect = abPickerCanvas.getBoundingClientRect();
      const normalizedX = clamp01((event.clientX - rect.left) / rect.width);
      const normalizedY = clamp01((event.clientY - rect.top) / rect.height);

      // Map normalized coordinates to OKLab a,b range
      const targetA = normalizedX * 2 * AB_RANGE - AB_RANGE;  // left=-0.4, right=+0.4
      const targetB = AB_RANGE - normalizedY * 2 * AB_RANGE;  // top=+0.4, bottom=-0.4

      // Clamp to working gamut by reducing chroma (preserving hue)
      [currentA, currentB] = clampToWorkingGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the lightness slider and update
     * currentL accordingly.
     */
    function updateLightnessFromPointer(event) {
      const rect = lightnessSliderCanvas.getBoundingClientRect();
      currentL = clamp01((event.clientX - rect.left) / rect.width);  // left=0, right=1
      // Clamp a,b to stay in gamut at the new lightness
      [currentA, currentB] = clampToWorkingGamut(currentL, currentA, currentB);
    }

    /**
     * Read pointer position over the chroma slider and update
     * currentA and currentB (keeping hue constant).
     */
    function updateChromaFromPointer(event) {
      const rect = chromaSliderCanvas.getBoundingClientRect();
      const newChroma = clamp01((event.clientX - rect.left) / rect.width) * CHROMA_MAX;
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(newChroma, currentHue);
      // Clamp chroma to gamut boundary
      [currentA, currentB] = clampToWorkingGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the hue slider and update
     * currentA and currentB (keeping chroma constant).
     */
    function updateHueFromPointer(event) {
      const rect = hueSliderCanvas.getBoundingClientRect();
      const newHue = clamp01((event.clientX - rect.left) / rect.width) * 360;
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(currentChroma, newHue);
      // Clamp to gamut at new hue by reducing chroma if needed
      [currentA, currentB] = clampToWorkingGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the intensity track and update
     * lightIntensity accordingly (0 to INTENSITY_MAX).
     */
    function updateIntensityFromPointer(event) {
      const track = document.getElementById('intensity-track');
      const rect = track.getBoundingClientRect();
      lightIntensity = Math.max(0, Math.min(INTENSITY_MAX,
        ((event.clientX - rect.left) / rect.width) * INTENSITY_MAX
      ));
    }

    // â”€â”€ Pointer Down: begin drag â”€â”€
    abPickerCanvas.addEventListener('pointerdown', (event) => {
      isDraggingAB = true;
      abPickerCanvas.setPointerCapture(event.pointerId);
      updateABFromPointer(event);
      onABChanged();
    });

    lightnessSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingLightness = true;
      lightnessSliderCanvas.setPointerCapture(event.pointerId);
      updateLightnessFromPointer(event);
      onLightnessChanged();
    });

    chromaSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingChroma = true;
      chromaSliderCanvas.setPointerCapture(event.pointerId);
      updateChromaFromPointer(event);
      onChromaChanged();
    });

    hueSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingHue = true;
      hueSliderCanvas.setPointerCapture(event.pointerId);
      updateHueFromPointer(event);
      onHueChanged();
    });

    document.getElementById('intensity-track').addEventListener('pointerdown', (event) => {
      isDraggingIntensity = true;
      event.target.setPointerCapture(event.pointerId);
      updateIntensityFromPointer(event);
      updateLightingPanel();
      renderResultABMap();
    });

    // â”€â”€ Pointer Move: update during drag (throttled) â”€â”€
    window.addEventListener('pointermove', (event) => {
      if (!isDraggingAB && !isDraggingLightness && !isDraggingChroma && !isDraggingHue && !isDraggingIntensity) return;

      // Throttle to one update per animation frame to avoid jank
      if (isAnimationFramePending) return;
      isAnimationFramePending = true;

      requestAnimationFrame(() => {
        isAnimationFramePending = false;

        if (isDraggingAB) {
          updateABFromPointer(event);
          onABChanged();
        }
        if (isDraggingLightness) {
          updateLightnessFromPointer(event);
          onLightnessChanged();
        }
        if (isDraggingChroma) {
          updateChromaFromPointer(event);
          onChromaChanged();
        }
        if (isDraggingHue) {
          updateHueFromPointer(event);
          onHueChanged();
        }
        if (isDraggingIntensity) {
          updateIntensityFromPointer(event);
          updateLightingPanel();
          renderResultABMap();
        }
      });
    });

    // â”€â”€ Pointer Up: end drag â†’ commit to history â”€â”€
    window.addEventListener('pointerup', () => {
      const wasDragging = isDraggingAB || isDraggingLightness || isDraggingChroma || isDraggingHue;
      const wasIntensity = isDraggingIntensity;
      isDraggingAB = false;
      isDraggingLightness = false;
      isDraggingChroma = false;
      isDraggingHue = false;
      isDraggingIntensity = false;
      if (wasDragging) {
        pushColorToHistory();
      }
      if (wasIntensity) {
        scheduleSave();
      }
    });


    // ================================================================
    //  ALWAYS ON TOP
    //  Toggles the Electron window's always-on-top state via IPC.
    // ================================================================

    function toggleAlwaysOnTop() {
      isAlwaysOnTop = !isAlwaysOnTop;
      ipcRenderer.send('set-aot', isAlwaysOnTop);
      document.getElementById('always-on-top-button').classList.toggle('active', isAlwaysOnTop);
    }


    // ================================================================
    //  EYEDROPPER COLOR PICKER
    //  Uses the EyeDropper API to sample a color from anywhere on screen.
    //  The sampled sRGB hex is converted back to OKLab to update the UI.
    // ================================================================

    async function pickColor() {
      try {
        const result = await new EyeDropper().open();
        const hex = result.sRGBHex; // e.g. "#ff8040"

        // Parse hex â†’ gamma-encoded channel values [0, 1]
        const gammaR = parseInt(hex.slice(1, 3), 16) / 255;
        const gammaG = parseInt(hex.slice(3, 5), 16) / 255;
        const gammaB = parseInt(hex.slice(5, 7), 16) / 255;

        // Decode gamma using working color space transfer curves.
        // The EyeDropper API returns raw framebuffer values â€” these are in
        // the display's color space (the working CS) before any conversion.
        let linearR, linearG, linearB;
        if (workingCS.perChannelTRC) {
          linearR = workingCS.decode(gammaR, 0);
          linearG = workingCS.decode(gammaG, 1);
          linearB = workingCS.decode(gammaB, 2);
        } else {
          linearR = workingCS.decode(gammaR);
          linearG = workingCS.decode(gammaG);
          linearB = workingCS.decode(gammaB);
        }

        // Convert from linear working CS â†’ linear sRGB â†’ OKLab
        [linearR, linearG, linearB] = workingCS.toLinearSRGB(linearR, linearG, linearB);

        // Convert linear sRGB â†’ OKLab
        const [L, a, b] = linearSRGBToOKLab(linearR, linearG, linearB);

        currentL = L;
        currentA = a;
        currentB = b;
        writePickerToEditTarget();
        pushColorToHistory();
        renderAll();
      } catch (error) {
        // User cancelled the eyedropper â€” no action needed
      }
    }

    // ================================================================
    //  COPY TO CLIPBOARD
    //  Copies the text content of a given element to the clipboard
    //  and briefly shows a checkmark on the button for feedback.
    // ================================================================

    async function copyToClipboard(button, elementId) {
      const text = document.getElementById(elementId).textContent;
      await navigator.clipboard.writeText(text);

      // Show brief "copied" feedback
      const originalText = button.textContent;
      button.textContent = 'âœ“';
      setTimeout(() => {
        button.textContent = originalText;
      }, 700);
    }


    // ================================================================
    //  INITIALIZATION
    // ================================================================

    // Apply default states to UI
    ipcRenderer.send('set-aot', true);
    document.getElementById('always-on-top-button').classList.add('active');

    // Restore saved state (colors, history, ICC profile, lighting panel)
    restoreState();
    updateWorkingCSDisplay();

    renderAll();


    // ================================================================
    //  COLOR SELECTION HISTORY
    //  Independent history stacks for main picker, albedo, and light.
    //  Ctrl+Z navigates backward, Ctrl+Shift+Z forward.
    //  New selections always append to the top; forward history is
    //  preserved (this is navigation, not undo/redo).
    // ================================================================

    /**
     * Get the active history stack based on the current mode.
     */
    function getActiveHistory() {
      if (!isLightingOpen) return historyMain;
      return editTarget === 'albedo' ? historyAlbedo : historyLight;
    }

    /**
     * Push the current color onto the active history stack.
     * Moves position to the new top entry.
     */
    function pushColorToHistory() {
      const h = getActiveHistory();
      const last = h.entries[h.entries.length - 1];
      // Skip duplicate if color hasn't actually changed
      if (last &&
          Math.abs(last[0] - currentL) < 1e-6 &&
          Math.abs(last[1] - currentA) < 1e-6 &&
          Math.abs(last[2] - currentB) < 1e-6) {
        return;
      }
      h.entries.push([currentL, currentA, currentB]);
      if (h.entries.length > MAX_HISTORY) h.entries.shift();
      h.pos = h.entries.length - 1;
      scheduleSave();
    }

    /**
     * Navigate to a history entry and apply its color.
     */
    function applyHistoryEntry(h) {
      const [L, a, b] = h.entries[h.pos];
      currentL = L;
      currentA = a;
      currentB = b;
      writePickerToEditTarget();
      renderAll();
      scheduleSave();
    }

    /**
     * Step backward in the active history (Ctrl+Z).
     */
    function historyBack() {
      const h = getActiveHistory();
      if (h.pos > 0) {
        h.pos--;
        applyHistoryEntry(h);
      }
    }

    /**
     * Step forward in the active history (Ctrl+Shift+Z).
     */
    function historyForward() {
      const h = getActiveHistory();
      if (h.pos < h.entries.length - 1) {
        h.pos++;
        applyHistoryEntry(h);
      }
    }

    // â”€â”€ Keyboard shortcuts â”€â”€
    window.addEventListener('keydown', (event) => {
      if (event.key === 'z' && event.ctrlKey && !event.shiftKey) {
        event.preventDefault();
        historyBack();
      } else if (event.key === 'Z' && event.ctrlKey && event.shiftKey) {
        event.preventDefault();
        historyForward();
      }
    });
  </script>

</body>
</html>
