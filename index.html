<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>OKLab Color Picker</title>

  <style>
    /* â”€â”€ Reset & Base â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font: 13px/1.4 'Segoe UI', system-ui, sans-serif;
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 16px;
      user-select: none;
    }

    /* â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }

    .toolbar button {
      flex: 1;
      padding: 7px;
      border: 1px solid #45475a;
      background: #313244;
      color: #cdd6f4;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .toolbar button:hover {
      background: #45475a;
    }

    .toolbar button.active {
      background: #a6e3a1;
      color: #1e1e2e;
      border-color: #a6e3a1;
    }

    .toolbar button.active-warn {
      background: #f9e2af;
      color: #1e1e2e;
      border-color: #f9e2af;
    }

    /* â”€â”€ 2D Picker (a, b axes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .picker-wrap {
      position: relative;
      width: 300px;
      margin: 0 auto;
    }

    #ab-picker {
      display: block;
      border-radius: 8px;
      cursor: crosshair;
    }

    /* Axis labels positioned around the picker */
    .axis-label {
      position: absolute;
      font-size: 9px;
      color: #6c7086;
      pointer-events: none;
    }

    .axis-label.top {
      top: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.bottom {
      bottom: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.left {
      left: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg);
    }

    .axis-label.right {
      right: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(90deg);
    }

    /* â”€â”€ Sliders (Lightness, Chroma, Hue) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    .slider-canvas {
      display: block;
      border-radius: 6px;
      cursor: crosshair;
      margin: 16px auto 0;
    }

    .slider-label {
      display: block;
      width: 300px;
      margin: 6px auto 0;
      font-size: 9px;
      color: #6c7086;
      text-align: center;
    }

    /* â”€â”€ Info Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ */
    #info {
      margin: 14px auto 0;
      width: 300px;
    }

    .color-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    #color-preview {
      width: 56px;
      height: 56px;
      border-radius: 8px;
      border: 2px solid #45475a;
      flex-shrink: 0;
    }

    #oklab-values {
      font: 12px 'Cascadia Code', 'Consolas', monospace;
      line-height: 1.7;
    }

    /* Hex value rows */
    .hex-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      font: 12px 'Cascadia Code', 'Consolas', monospace;
    }

    .hex-row label {
      min-width: 72px;
      color: #6c7086;
      font-family: inherit;
    }

    .hex-value {
      padding: 2px 8px;
      background: #313244;
      border-radius: 4px;
    }

    .copy-button {
      padding: 2px 7px;
      border: none;
      background: #45475a;
      color: #cdd6f4;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .copy-button:hover {
      background: #585b70;
    }

    /* Gamut indicators */
    .in-gamut {
      color: #a6e3a1;
      font-size: 11px;
    }

    .out-of-gamut {
      color: #f38ba8;
      font-size: 11px;
    }
  </style>
</head>

<body>

  <!-- â”€â”€ Toolbar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="toolbar">
    <button id="always-on-top-button" onclick="toggleAlwaysOnTop()">ðŸ“Œ Always on Top</button>
    <button onclick="pickColor()">ðŸ’§ Pick Color <kbd style="opacity: 0.6; font-size: 10px">Alt+C</kbd></button>
  </div>
  <div class="toolbar">
    <button id="pick-as-display-button" onclick="togglePickAsDisplay()" title="Interpret picked colors as display-native (P3) values instead of sRGB. Enable this when picking from wide-gamut apps.">
      ðŸŽ¨ Picker assumes: <span id="pick-space-label">sRGB</span>
    </button>
  </div>

  <!-- â”€â”€ 2D Color Picker (a, b axes) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div class="picker-wrap">
    <canvas id="ab-picker" width="300" height="300"></canvas>
    <span class="axis-label top">+b (yellow)</span>
    <span class="axis-label bottom">âˆ’b (blue)</span>
    <span class="axis-label left">âˆ’a (green)</span>
    <span class="axis-label right">+a (red)</span>
  </div>

  <!-- â”€â”€ Lightness Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="lightness-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">L: Lightness (0 â†’ 1)</span>

  <!-- â”€â”€ Chroma Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="chroma-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">C: Chroma (0 â†’ 0.4)</span>

  <!-- â”€â”€ Hue Slider â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <canvas id="hue-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">h: Hue (0Â° â†’ 360Â°)</span>

  <!-- â”€â”€ Color Info Panel â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ -->
  <div id="info">
    <!-- Preview swatch + OKLab values -->
    <div class="color-row">
      <div id="color-preview"></div>
      <div id="oklab-values"></div>
    </div>

    <!-- sRGB hex code -->
    <div class="hex-row">
      <label>sRGB:</label>
      <span class="hex-value" id="srgb-hex"></span>
      <span id="srgb-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'srgb-hex')">ðŸ“‹</button>
    </div>

    <!-- Display P3 hex code -->
    <div class="hex-row">
      <label id="display-color-space-label">Display P3:</label>
      <span class="hex-value" id="display-hex"></span>
      <span id="display-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'display-hex')">ðŸ“‹</button>
    </div>

    <!-- Raw CSS oklab() value -->
    <div class="hex-row">
      <label>CSS:</label>
      <span class="hex-value" id="css-oklab-value"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'css-oklab-value')">ðŸ“‹</button>
    </div>
  </div>


  <script>
    const { ipcRenderer } = require('electron');


    // ================================================================
    //  COLOR MATH
    //  Conversion functions between OKLab, linear sRGB, and Display P3.
    //  All use linear-light (pre-gamma) values unless noted otherwise.
    //  Matrix coefficients from https://bottosson.github.io/posts/oklab/
    // ================================================================

    /**
     * Convert OKLab (L, a, b) â†’ linear sRGB (r, g, b).
     *
     * Steps:
     *   1. OKLab â†’ LMS (cone response, cubed-root space)
     *   2. Undo cube root to get linear LMS
     *   3. Linear LMS â†’ linear sRGB via 3Ã—3 matrix
     */
    function oklabToLinearSRGB(L, a, b) {
      // Step 1: OKLab â†’ LMS (cube-root encoded)
      const lCubeRoot = L + 0.3963377774 * a + 0.2158037573 * b;
      const mCubeRoot = L - 0.1055613458 * a - 0.0638541728 * b;
      const sCubeRoot = L - 0.0894841775 * a - 1.2914855480 * b;

      // Step 2: Undo the cube root â†’ linear LMS
      const lLinear = lCubeRoot ** 3;
      const mLinear = mCubeRoot ** 3;
      const sLinear = sCubeRoot ** 3;

      // Step 3: LMS â†’ linear sRGB (3Ã—3 matrix multiply)
      const red   =  4.0767416621 * lLinear - 3.3077115913 * mLinear + 0.2309699292 * sLinear;
      const green = -1.2684380046 * lLinear + 2.6097574011 * mLinear - 0.3413193965 * sLinear;
      const blue  = -0.0041960863 * lLinear - 0.7034186147 * mLinear + 1.7076147010 * sLinear;

      return [red, green, blue];
    }

    /**
     * Convert linear sRGB (r, g, b) â†’ linear Display P3 (r, g, b).
     *
     * This is a direct 3Ã—3 matrix transform between the two RGB spaces.
     * Both share the same whitepoint (D65) but have different primaries.
     */
    function linearSRGBToLinearP3(r, g, b) {
      return [
        0.8224621209 * r + 0.1775378791 * g,
        0.0331941826 * r + 0.9668058174 * g,
        0.0170826307 * r + 0.0723974407 * g + 0.9105199286 * b
      ];
    }

    /**
     * Convert linear Display P3 (r, g, b) â†’ linear sRGB (r, g, b).
     *
     * This is the inverse of linearSRGBToLinearP3.
     * Used when interpreting eyedropper-picked colors as display-native P3.
     */
    function linearP3ToLinearSRGB(r, g, b) {
      return [
         1.2249401762 * r - 0.2249401762 * g,
        -0.0420569549 * r + 1.0420569549 * g,
        -0.0196375546 * r - 0.0786360236 * g + 1.0982735782 * b
      ];
    }

    // ================================================================
    //  OKLab â†” OKLCH CONVERSION
    //  OKLCH is the cylindrical (polar) form of OKLab:
    //    C = chroma = sqrt(aÂ² + bÂ²)
    //    h = hue    = atan2(b, a)  (in degrees, 0â€“360)
    // ================================================================

    /**
     * Convert OKLab (a, b) â†’ OKLCH (C, h).
     * Returns [chroma, hueDegrees].
     */
    function oklabToOklch(a, b) {
      const chroma = Math.sqrt(a * a + b * b);
      let hueDegrees = Math.atan2(b, a) * (180 / Math.PI);
      if (hueDegrees < 0) hueDegrees += 360;
      return [chroma, hueDegrees];
    }

    /**
     * Convert OKLCH (C, h) â†’ OKLab (a, b).
     * hue is in degrees.
     */
    function oklchToOklab(chroma, hueDegrees) {
      const hueRadians = hueDegrees * (Math.PI / 180);
      const a = chroma * Math.cos(hueRadians);
      const b = chroma * Math.sin(hueRadians);
      return [a, b];
    }


    /**
     * Convert linear sRGB (r, g, b) â†’ OKLab (L, a, b).
     *
     * Steps:
     *   1. Linear sRGB â†’ linear LMS via 3Ã—3 matrix
     *   2. Cube root of LMS (perceptual compression)
     *   3. Cube-root LMS â†’ OKLab via 3Ã—3 matrix
     */
    function linearSRGBToOKLab(r, g, b) {
      // Step 1: Linear sRGB â†’ linear LMS
      const lLinear = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
      const mLinear = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
      const sLinear = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

      // Step 2: Cube root (perceptual non-linearity)
      const lRoot = Math.cbrt(lLinear);
      const mRoot = Math.cbrt(mLinear);
      const sRoot = Math.cbrt(sLinear);

      // Step 3: Cube-root LMS â†’ OKLab
      const L =  0.2104542553 * lRoot + 0.7936177850 * mRoot - 0.0040720468 * sRoot;
      const a =  1.9779984951 * lRoot - 2.4285922050 * mRoot + 0.4505937099 * sRoot;
      const ob = 0.0259040371 * lRoot + 0.7827717662 * mRoot - 0.8086757660 * sRoot;

      return [L, a, ob];
    }


    // ================================================================
    //  GAMMA / UTILITY FUNCTIONS
    // ================================================================

    /**
     * Apply sRGB gamma encoding (linear â†’ gamma-encoded).
     * Input is clamped to [0, 1] before encoding.
     * The sRGB transfer function has a linear segment near zero
     * and a power curve for the rest.
     */
    function linearToGamma(linearValue) {
      const clamped = Math.max(0, Math.min(1, linearValue));
      if (clamped >= 0.0031308) {
        return 1.055 * (clamped ** (1 / 2.4)) - 0.055;
      }
      return 12.92 * clamped;
    }

    /**
     * Remove sRGB gamma encoding (gamma-encoded â†’ linear).
     * Inverse of linearToGamma().
     */
    function gammaToLinear(gammaValue) {
      if (gammaValue >= 0.04045) {
        return ((gammaValue + 0.055) / 1.055) ** 2.4;
      }
      return gammaValue / 12.92;
    }

    /** Clamp a value to the [0, 1] range. */
    function clamp01(value) {
      return Math.max(0, Math.min(1, value));
    }

    /**
     * Check whether (r, g, b) values fall within the [0, 1] gamut.
     * A small tolerance (Â±0.0005) is used to avoid false negatives
     * from floating-point rounding in the matrix conversions.
     */
    function isInGamut(r, g, b) {
      const TOLERANCE = 5e-4;
      return (
        r >= -TOLERANCE && r <= 1 + TOLERANCE &&
        g >= -TOLERANCE && g <= 1 + TOLERANCE &&
        b >= -TOLERANCE && b <= 1 + TOLERANCE
      );
    }

    /**
     * Convert gamma-encoded (r, g, b) in [0,1] to a hex color string.
     * Example: (1, 0.5, 0) â†’ "#ff8000"
     */
    function rgbToHex(r, g, b) {
      const toByteHex = (value) =>
        Math.round(clamp01(value) * 255)
          .toString(16)
          .padStart(2, '0');
      return '#' + toByteHex(r) + toByteHex(g) + toByteHex(b);
    }

    /** Convert a linear channel value to a 0â€“255 byte for ImageData. */
    function linearToColorByte(linearValue) {
      return Math.round(linearToGamma(linearValue) * 255);
    }


    // ================================================================
    //  APPLICATION STATE
    // ================================================================

    /** Current OKLab color components */
    let currentL = 0.7;   // Lightness: 0 (black) to 1 (white)
    let currentA = 0.0;   // Greenâ€“Red axis: roughly âˆ’0.4 to +0.4
    let currentB = 0.0;   // Blueâ€“Yellow axis: roughly âˆ’0.4 to +0.4

    /** Whether the window is set to always-on-top */
    let isAlwaysOnTop = false;

    /** Whether to interpret eyedropper-picked colors as display-native (P3) */
    let interpretPickedAsDisplay = false;

    /** Canvas dimensions & OKLab axis range */
    const PICKER_SIZE = 300;         // Width & height of the a,b picker (px)
    const AB_RANGE = 0.4;            // a,b axis extends from -0.4 to +0.4
    const SLIDER_HEIGHT = 28;        // Height of each slider (px)
    const CHROMA_MAX = 0.4;            // Maximum chroma value for the slider


    // ================================================================
    //  CANVAS SETUP
    //  If the browser supports Display P3 canvases (wide gamut), we use
    //  that color space so colors outside sRGB can be shown accurately
    //  on a wide-gamut monitor. Otherwise we fall back to sRGB.
    // ================================================================

    const abPickerCanvas = document.getElementById('ab-picker');
    const lightnessSliderCanvas = document.getElementById('lightness-slider');
    const chromaSliderCanvas = document.getElementById('chroma-slider');
    const hueSliderCanvas = document.getElementById('hue-slider');

    // Detect whether the display supports the P3 wide color gamut.
    // If it does, we use a 'display-p3' canvas so colors outside sRGB render accurately.
    const isDisplayP3Supported = window.matchMedia('(color-gamut: p3)').matches;
    const canvasColorSpace = isDisplayP3Supported ? 'display-p3' : 'srgb';
    const canvasOptions = { colorSpace: canvasColorSpace };
    const abPickerContext = abPickerCanvas.getContext('2d', canvasOptions);
    const lightnessContext = lightnessSliderCanvas.getContext('2d', canvasOptions);
    const chromaContext = chromaSliderCanvas.getContext('2d', canvasOptions);
    const hueContext = hueSliderCanvas.getContext('2d', canvasOptions);

    // Update the display color space label if P3 is not available
    if (!isDisplayP3Supported) {
      document.getElementById('display-color-space-label').textContent = 'sRGB (disp):';
    }


    // ================================================================
    //  GAMUT HELPERS
    //  Functions for checking and clamping colors to the display gamut.
    //  Uses P3 if the display supports it, otherwise sRGB.
    // ================================================================

    /**
     * Check whether an OKLab color falls within the display's color gamut.
     */
    function isInDisplayGamut(L, a, b) {
      const [linearR, linearG, linearB] = oklabToLinearSRGB(L, a, b);
      if (isDisplayP3Supported) {
        const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
        return isInGamut(p3R, p3G, p3B);
      }
      return isInGamut(linearR, linearG, linearB);
    }

    /**
     * Binary-search for the maximum chroma that keeps the color in the
     * display gamut at a given lightness and hue angle.
     * @returns {number} Maximum in-gamut chroma
     */
    function findMaxInGamutChroma(L, hueDegrees, maxSearch = CHROMA_MAX) {
      const [aHi, bHi] = oklchToOklab(maxSearch, hueDegrees);
      if (isInDisplayGamut(L, aHi, bHi)) return maxSearch;
      let lo = 0, hi = maxSearch;
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        const [a, b] = oklchToOklab(mid, hueDegrees);
        if (isInDisplayGamut(L, a, b)) { lo = mid; } else { hi = mid; }
      }
      return lo;
    }

    /**
     * Clamp an OKLab color to the display gamut by reducing chroma
     * while preserving lightness and hue.
     * @returns {[number, number]} Clamped [a, b] values
     */
    function clampToDisplayGamut(L, a, b) {
      if (isInDisplayGamut(L, a, b)) return [a, b];
      const [chroma, hue] = oklabToOklch(a, b);
      const maxChroma = findMaxInGamutChroma(L, hue, chroma);
      return oklchToOklab(maxChroma, hue);
    }


    // ================================================================
    //  RENDERING: a,b PICKER
    //  Draws a 300Ã—300 image where each pixel represents an OKLab color
    //  at the current lightness (L). The x-axis maps to 'a' (greenâ†’red),
    //  and the y-axis maps to 'b' (blueâ†’yellow, top = +b).
    // ================================================================

    /** Cached ImageData for the a,b picker background */
    let abPickerImageData = null;

    /**
     * Compute the pixel colors for every (a, b) combination at the
     * current lightness value and store them in abPickerImageData.
     */
    function renderABPickerColors() {
      abPickerImageData = abPickerContext.createImageData(PICKER_SIZE, PICKER_SIZE);
      const pixels = abPickerImageData.data;
      const step = (2 * AB_RANGE) / (PICKER_SIZE - 1);

      for (let y = 0; y < PICKER_SIZE; y++) {
        // Top of canvas = +AB_RANGE (positive b), bottom = -AB_RANGE
        const bValue = AB_RANGE - y * step;

        for (let x = 0; x < PICKER_SIZE; x++) {
          // Left of canvas = -AB_RANGE (negative a), right = +AB_RANGE
          const aValue = -AB_RANGE + x * step;

          // Convert this OKLab color to linear sRGB
          const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, aValue, bValue);

          // Calculate the pixel offset in the ImageData buffer (4 bytes per pixel: RGBA)
          const pixelIndex = (y * PICKER_SIZE + x) * 4;

          let byteR, byteG, byteB, inGamut;
          if (isDisplayP3Supported) {
            const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
            inGamut = isInGamut(p3R, p3G, p3B);
            byteR = linearToColorByte(p3R);
            byteG = linearToColorByte(p3G);
            byteB = linearToColorByte(p3B);
          } else {
            inGamut = isInGamut(linearR, linearG, linearB);
            byteR = linearToColorByte(linearR);
            byteG = linearToColorByte(linearG);
            byteB = linearToColorByte(linearB);
          }

          // Darken out-of-gamut pixels with diagonal stripe pattern
          if (!inGamut) {
            byteR = Math.round(byteR * 0.15);
            byteG = Math.round(byteG * 0.15);
            byteB = Math.round(byteB * 0.15);
            if ((x + y) % 6 < 1) {
              byteR = Math.min(255, byteR + 35);
              byteG = Math.min(255, byteG + 35);
              byteB = Math.min(255, byteB + 35);
            }
          }

          pixels[pixelIndex]     = byteR;
          pixels[pixelIndex + 1] = byteG;
          pixels[pixelIndex + 2] = byteB;
          pixels[pixelIndex + 3] = 255; // Fully opaque
        }
      }
    }

    /**
     * Draw the a,b picker: blit the cached color image, then draw
     * a crosshair circle at the currently selected (a, b) position.
     */
    function drawABPicker() {
      if (!abPickerImageData) return;

      // Draw the pre-computed color field
      abPickerContext.putImageData(abPickerImageData, 0, 0);

      // Convert current (a, b) values to canvas pixel coordinates
      const cursorX = ((currentA + AB_RANGE) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);
      const cursorY = ((AB_RANGE - currentB) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);

      // Use contrasting colors for the crosshair depending on lightness
      const isDark = currentL > 0.5;

      // Inner ring (strong contrast)
      abPickerContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      abPickerContext.lineWidth = 2.5;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 7, 0, 2 * Math.PI);
      abPickerContext.stroke();

      // Outer ring (subtle halo for visibility)
      abPickerContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      abPickerContext.lineWidth = 1;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 9, 0, 2 * Math.PI);
      abPickerContext.stroke();
    }


    // ================================================================
    //  RENDERING: LIGHTNESS SLIDER
    //  A horizontal bar where each pixel column represents a different
    //  lightness (L) value at the current (a, b). Left = 0, right = 1.
    // ================================================================

    /** Cached ImageData for the lightness slider background */
    let lightnessImageData = null;

    /**
     * Compute the pixel colors for the lightness slider at the
     * current (a, b) values.
     */
    function renderLightnessSliderColors() {
      lightnessImageData = lightnessContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = lightnessImageData.data;

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to lightness value [0, 1]
        const lightnessValue = x / (PICKER_SIZE - 1);

        // Convert this OKLab color to linear sRGB
        const [linearR, linearG, linearB] = oklabToLinearSRGB(lightnessValue, currentA, currentB);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the lightness slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected L value.
     */
    function drawLightnessSlider() {
      if (!lightnessImageData) return;

      // Draw the pre-computed gradient
      lightnessContext.putImageData(lightnessImageData, 0, 0);

      // Convert current L to a pixel x-coordinate
      const indicatorX = currentL * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      lightnessContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      lightnessContext.lineWidth = 3;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX, 0);
      lightnessContext.lineTo(indicatorX, SLIDER_HEIGHT);
      lightnessContext.stroke();

      // Flanking lines for contrast
      lightnessContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      lightnessContext.lineWidth = 1;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX - 2, 0);
      lightnessContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      lightnessContext.moveTo(indicatorX + 2, 0);
      lightnessContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      lightnessContext.stroke();
    }


    // ================================================================
    //  RENDERING: CHROMA SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  chroma (C) value, keeping the current L and hue constant.
    //  Left = 0, right = CHROMA_MAX.
    // ================================================================

    /** Cached ImageData for the chroma slider background */
    let chromaImageData = null;

    /**
     * Compute the pixel colors for the chroma slider at the
     * current lightness and hue.
     */
    function renderChromaSliderColors() {
      chromaImageData = chromaContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = chromaImageData.data;
      const [, currentHue] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to chroma value [0, CHROMA_MAX]
        const chromaValue = (x / (PICKER_SIZE - 1)) * CHROMA_MAX;

        // Convert OKLCH â†’ OKLab â†’ linear sRGB
        const [a, b] = oklchToOklab(chromaValue, currentHue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the chroma slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected chroma.
     */
    function drawChromaSlider() {
      if (!chromaImageData) return;

      chromaContext.putImageData(chromaImageData, 0, 0);

      // Compute current chroma and map to pixel position
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentChroma / CHROMA_MAX) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      chromaContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      chromaContext.lineWidth = 3;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX, 0);
      chromaContext.lineTo(indicatorX, SLIDER_HEIGHT);
      chromaContext.stroke();

      // Flanking lines for contrast
      chromaContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      chromaContext.lineWidth = 1;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX - 2, 0);
      chromaContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      chromaContext.moveTo(indicatorX + 2, 0);
      chromaContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      chromaContext.stroke();
    }


    // ================================================================
    //  RENDERING: HUE SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  hue angle, keeping the current L and chroma constant.
    //  Left = 0Â°, right = 360Â°.
    // ================================================================

    /** Cached ImageData for the hue slider background */
    let hueImageData = null;

    /**
     * Compute the pixel colors for the hue slider at the
     * current lightness and chroma.
     */
    function renderHueSliderColors() {
      hueImageData = hueContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = hueImageData.data;
      const [currentChroma] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to hue value [0, 360)
        const hueValue = (x / (PICKER_SIZE - 1)) * 360;

        // Convert OKLCH â†’ OKLab â†’ linear sRGB
        const [a, b] = oklchToOklab(currentChroma, hueValue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the hue slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected hue.
     */
    function drawHueSlider() {
      if (!hueImageData) return;

      hueContext.putImageData(hueImageData, 0, 0);

      // Compute current hue and map to pixel position
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentHue / 360) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      hueContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      hueContext.lineWidth = 3;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX, 0);
      hueContext.lineTo(indicatorX, SLIDER_HEIGHT);
      hueContext.stroke();

      // Flanking lines for contrast
      hueContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      hueContext.lineWidth = 1;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX - 2, 0);
      hueContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      hueContext.moveTo(indicatorX + 2, 0);
      hueContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      hueContext.stroke();
    }


    // ================================================================
    //  INFO PANEL
    //  Updates the color preview swatch, OKLab/OKLCH readout, hex codes,
    //  and gamut indicators.
    // ================================================================

    function updateInfoPanel() {
      // Convert current OKLab â†’ linear sRGB
      const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, currentA, currentB);

      // Check sRGB gamut and compute hex
      const srgbInGamut = isInGamut(linearR, linearG, linearB);
      const srgbHex = rgbToHex(
        linearToGamma(linearR),
        linearToGamma(linearG),
        linearToGamma(linearB)
      );

      // Convert to Display P3, check gamut, compute hex
      const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
      const displayInGamut = isInGamut(p3R, p3G, p3B);
      const displayHex = rgbToHex(
        linearToGamma(p3R),
        linearToGamma(p3G),
        linearToGamma(p3B)
      );

      // Compute OKLCH values for display
      const [currentChroma, currentHue] = oklabToOklch(currentA, currentB);

      // Update the OKLab + OKLCH numeric readout
      document.getElementById('oklab-values').innerHTML =
        `L: <b>${currentL.toFixed(3)}</b>&ensp;` +
        `a: <b>${currentA.toFixed(3)}</b>&ensp;` +
        `b: <b>${currentB.toFixed(3)}</b><br>` +
        `C: <b>${currentChroma.toFixed(3)}</b>&ensp;` +
        `h: <b>${currentHue.toFixed(1)}Â°</b>`;

      // Update the preview swatch using native CSS oklab() for correct rendering
      document.getElementById('color-preview').style.background =
        `oklab(${currentL} ${currentA} ${currentB})`;

      // Update sRGB hex and gamut indicator
      document.getElementById('srgb-hex').textContent = srgbHex;
      document.getElementById('srgb-gamut-indicator').innerHTML = srgbInGamut
        ? '<span class="in-gamut" title="In sRGB gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of sRGB gamut">âœ— out of gamut</span>';

      // Update display color space hex and gamut indicator
      document.getElementById('display-hex').textContent = displayHex;
      document.getElementById('display-gamut-indicator').innerHTML = displayInGamut
        ? '<span class="in-gamut" title="In Display P3 gamut">âœ“</span>'
        : '<span class="out-of-gamut" title="Out of Display P3 gamut">âœ— out of gamut</span>';

      // Update the raw CSS oklab() value
      document.getElementById('css-oklab-value').textContent =
        `oklab(${currentL.toFixed(3)} ${currentA.toFixed(3)} ${currentB.toFixed(3)})`;
    }


    // ================================================================
    //  RENDER ORCHESTRATION
    //  Different interactions require recomputing different parts:
    //  - renderAll: recompute everything (initial load, color pick)
    //  - onABChanged: a or b changed â†’ recompute L slider, redraw both
    //  - onLightnessChanged: L changed â†’ recompute a,b field, redraw both
    // ================================================================

    /** Helper: redraw all slider indicators + info (no pixel recomputation) */
    function drawAllSliders() {
      drawLightnessSlider();
      drawChromaSlider();
      drawHueSlider();
    }

    /** Helper: recompute all slider gradients */
    function renderAllSliderColors() {
      renderLightnessSliderColors();
      renderChromaSliderColors();
      renderHueSliderColors();
    }

    function renderAll() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
    }

    function onABChanged() {
      // The a,b picker image is still valid (L hasn't changed),
      // but all slider gradients need to update.
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
    }

    function onLightnessChanged() {
      // L changed, so the entire a,b color field must be recomputed.
      // All slider gradients also depend on L.
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
    }

    function onChromaChanged() {
      // Chroma changed â†’ a,b changed, so recompute a,b picker + all sliders.
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
    }

    function onHueChanged() {
      // Hue changed â†’ a,b changed, so recompute a,b picker + all sliders.
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
    }


    // ================================================================
    //  POINTER INTERACTION
    //  Handles click-and-drag on both the a,b picker and the L slider.
    //  Uses requestAnimationFrame to throttle redraws during drag.
    // ================================================================

    let isDraggingAB = false;
    let isDraggingLightness = false;
    let isDraggingChroma = false;
    let isDraggingHue = false;
    let isAnimationFramePending = false;

    /**
     * Read pointer position over the a,b picker canvas and update
     * currentA and currentB accordingly.
     */
    function updateABFromPointer(event) {
      const rect = abPickerCanvas.getBoundingClientRect();
      const normalizedX = clamp01((event.clientX - rect.left) / rect.width);
      const normalizedY = clamp01((event.clientY - rect.top) / rect.height);

      // Map normalized coordinates to OKLab a,b range
      const targetA = normalizedX * 2 * AB_RANGE - AB_RANGE;  // left=-0.4, right=+0.4
      const targetB = AB_RANGE - normalizedY * 2 * AB_RANGE;  // top=+0.4, bottom=-0.4

      // Clamp to display gamut by reducing chroma (preserving hue)
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the lightness slider and update
     * currentL accordingly.
     */
    function updateLightnessFromPointer(event) {
      const rect = lightnessSliderCanvas.getBoundingClientRect();
      currentL = clamp01((event.clientX - rect.left) / rect.width);  // left=0, right=1
      // Clamp a,b to stay in gamut at the new lightness
      [currentA, currentB] = clampToDisplayGamut(currentL, currentA, currentB);
    }

    /**
     * Read pointer position over the chroma slider and update
     * currentA and currentB (keeping hue constant).
     */
    function updateChromaFromPointer(event) {
      const rect = chromaSliderCanvas.getBoundingClientRect();
      const newChroma = clamp01((event.clientX - rect.left) / rect.width) * CHROMA_MAX;
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(newChroma, currentHue);
      // Clamp chroma to gamut boundary
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the hue slider and update
     * currentA and currentB (keeping chroma constant).
     */
    function updateHueFromPointer(event) {
      const rect = hueSliderCanvas.getBoundingClientRect();
      const newHue = clamp01((event.clientX - rect.left) / rect.width) * 360;
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(currentChroma, newHue);
      // Clamp to gamut at new hue by reducing chroma if needed
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    // â”€â”€ Pointer Down: begin drag â”€â”€
    abPickerCanvas.addEventListener('pointerdown', (event) => {
      isDraggingAB = true;
      abPickerCanvas.setPointerCapture(event.pointerId);
      updateABFromPointer(event);
      onABChanged();
    });

    lightnessSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingLightness = true;
      lightnessSliderCanvas.setPointerCapture(event.pointerId);
      updateLightnessFromPointer(event);
      onLightnessChanged();
    });

    chromaSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingChroma = true;
      chromaSliderCanvas.setPointerCapture(event.pointerId);
      updateChromaFromPointer(event);
      onChromaChanged();
    });

    hueSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingHue = true;
      hueSliderCanvas.setPointerCapture(event.pointerId);
      updateHueFromPointer(event);
      onHueChanged();
    });

    // â”€â”€ Pointer Move: update during drag (throttled) â”€â”€
    window.addEventListener('pointermove', (event) => {
      if (!isDraggingAB && !isDraggingLightness && !isDraggingChroma && !isDraggingHue) return;

      // Throttle to one update per animation frame to avoid jank
      if (isAnimationFramePending) return;
      isAnimationFramePending = true;

      requestAnimationFrame(() => {
        isAnimationFramePending = false;

        if (isDraggingAB) {
          updateABFromPointer(event);
          onABChanged();
        }
        if (isDraggingLightness) {
          updateLightnessFromPointer(event);
          onLightnessChanged();
        }
        if (isDraggingChroma) {
          updateChromaFromPointer(event);
          onChromaChanged();
        }
        if (isDraggingHue) {
          updateHueFromPointer(event);
          onHueChanged();
        }
      });
    });

    // â”€â”€ Pointer Up: end drag â”€â”€
    window.addEventListener('pointerup', () => {
      isDraggingAB = false;
      isDraggingLightness = false;
      isDraggingChroma = false;
      isDraggingHue = false;
    });


    // ================================================================
    //  ALWAYS ON TOP
    //  Toggles the Electron window's always-on-top state via IPC.
    // ================================================================

    function toggleAlwaysOnTop() {
      isAlwaysOnTop = !isAlwaysOnTop;
      ipcRenderer.send('set-aot', isAlwaysOnTop);
      document.getElementById('always-on-top-button').classList.toggle('active', isAlwaysOnTop);
    }


    // ================================================================
    //  EYEDROPPER COLOR PICKER
    //  Uses the EyeDropper API to sample a color from anywhere on screen.
    //  The sampled sRGB hex is converted back to OKLab to update the UI.
    // ================================================================

    async function pickColor() {
      try {
        const result = await new EyeDropper().open();
        const hex = result.sRGBHex; // e.g. "#ff8040"

        // Parse hex â†’ gamma-encoded channel values [0, 1]
        const gammaR = parseInt(hex.slice(1, 3), 16) / 255;
        const gammaG = parseInt(hex.slice(3, 5), 16) / 255;
        const gammaB = parseInt(hex.slice(5, 7), 16) / 255;

        // Decode gamma (sRGB and P3 share the same transfer function)
        let linearR = gammaToLinear(gammaR);
        let linearG = gammaToLinear(gammaG);
        let linearB = gammaToLinear(gammaB);

        // If the user wants to interpret picked colors as display-native P3,
        // convert from linear P3 â†’ linear sRGB before going to OKLab.
        // This compensates for the EyeDropper API returning raw framebuffer
        // values as "sRGB" when they're really in the display's color space.
        if (interpretPickedAsDisplay && isDisplayP3Supported) {
          [linearR, linearG, linearB] = linearP3ToLinearSRGB(linearR, linearG, linearB);
        }

        // Convert linear sRGB â†’ OKLab
        const [L, a, b] = linearSRGBToOKLab(linearR, linearG, linearB);

        currentL = L;
        currentA = a;
        currentB = b;
        renderAll();
      } catch (error) {
        // User cancelled the eyedropper â€” no action needed
      }
    }


    // ================================================================
    //  EYEDROPPER COLOR SPACE TOGGLE
    //  The EyeDropper API always returns sRGB hex, but on wide-gamut
    //  displays the raw pixel values may actually be in Display P3.
    //  This toggle lets the user choose the correct interpretation.
    // ================================================================

    function togglePickAsDisplay() {
      interpretPickedAsDisplay = !interpretPickedAsDisplay;
      const btn = document.getElementById('pick-as-display-button');
      const label = document.getElementById('pick-space-label');
      if (interpretPickedAsDisplay) {
        btn.classList.add('active-warn');
        label.textContent = isDisplayP3Supported ? 'Display P3' : 'sRGB (no P3)';
      } else {
        btn.classList.remove('active-warn');
        label.textContent = 'sRGB';
      }
    }


    // ================================================================
    //  COPY TO CLIPBOARD
    //  Copies the text content of a given element to the clipboard
    //  and briefly shows a checkmark on the button for feedback.
    // ================================================================

    async function copyToClipboard(button, elementId) {
      const text = document.getElementById(elementId).textContent;
      await navigator.clipboard.writeText(text);

      // Show brief "copied" feedback
      const originalText = button.textContent;
      button.textContent = 'âœ“';
      setTimeout(() => {
        button.textContent = originalText;
      }, 700);
    }


    // ================================================================
    //  INITIALIZATION
    // ================================================================

    renderAll();
  </script>

</body>
</html>
