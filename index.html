<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <title>OKLab Color Picker</title>

  <style>
    /* ‚îÄ‚îÄ Reset & Base ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font: 13px/1.4 'Segoe UI', system-ui, sans-serif;
      background: #1e1e2e;
      color: #cdd6f4;
      padding: 16px;
      user-select: none;
    }

    /* ‚îÄ‚îÄ Toolbar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .toolbar {
      display: flex;
      gap: 6px;
      margin-bottom: 12px;
    }

    .toolbar button {
      flex: 1;
      padding: 7px;
      border: 1px solid #45475a;
      background: #313244;
      color: #cdd6f4;
      border-radius: 6px;
      cursor: pointer;
      font-size: 12px;
    }

    .toolbar button:hover {
      background: #45475a;
    }

    .toolbar button.active {
      background: #a6e3a1;
      color: #1e1e2e;
      border-color: #a6e3a1;
    }

    .toolbar button.active-warn {
      background: #f9e2af;
      color: #1e1e2e;
      border-color: #f9e2af;
    }

    /* ‚îÄ‚îÄ 2D Picker (a, b axes) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .picker-wrap {
      position: relative;
      width: 300px;
      margin: 0 auto;
    }

    #ab-picker {
      display: block;
      border-radius: 8px;
      cursor: crosshair;
    }

    /* Axis labels positioned around the picker */
    .axis-label {
      position: absolute;
      font-size: 9px;
      color: #6c7086;
      pointer-events: none;
    }

    .axis-label.top {
      top: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.bottom {
      bottom: -13px;
      left: 50%;
      transform: translateX(-50%);
    }

    .axis-label.left {
      left: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(-90deg);
    }

    .axis-label.right {
      right: -16px;
      top: 50%;
      transform: translateY(-50%) rotate(90deg);
    }

    /* ‚îÄ‚îÄ Sliders (Lightness, Chroma, Hue) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    .slider-canvas {
      display: block;
      border-radius: 6px;
      cursor: crosshair;
      margin: 16px auto 0;
    }

    .slider-label {
      display: block;
      width: 300px;
      margin: 6px auto 0;
      font-size: 9px;
      color: #6c7086;
      text-align: center;
    }

    /* ‚îÄ‚îÄ Info Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    #info {
      margin: 14px auto 0;
      width: 300px;
    }

    .color-row {
      display: flex;
      align-items: center;
      gap: 10px;
      margin-bottom: 10px;
    }

    #color-preview {
      width: 56px;
      height: 56px;
      border-radius: 8px;
      border: 2px solid #45475a;
      flex-shrink: 0;
    }

    #oklab-values {
      font: 12px 'Cascadia Code', 'Consolas', monospace;
      line-height: 1.7;
    }

    /* Hex value rows */
    .hex-row {
      display: flex;
      align-items: center;
      gap: 6px;
      margin: 4px 0;
      font: 12px 'Cascadia Code', 'Consolas', monospace;
    }

    .hex-row label {
      min-width: 72px;
      color: #6c7086;
      font-family: inherit;
    }

    .hex-value {
      padding: 2px 8px;
      background: #313244;
      border-radius: 4px;
    }

    .copy-button {
      padding: 2px 7px;
      border: none;
      background: #45475a;
      color: #cdd6f4;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }

    .copy-button:hover {
      background: #585b70;
    }

    /* Gamut indicators */
    .in-gamut {
      color: #a6e3a1;
      font-size: 11px;
    }

    .out-of-gamut {
      color: #f38ba8;
      font-size: 11px;
    }

    /* ‚îÄ‚îÄ Lighting Lab Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ */
    #lighting-panel {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease, margin 0.3s ease;
      opacity: 0;
      margin: 0 auto;
      width: 300px;
    }

    #lighting-panel.open {
      max-height: 800px;
      opacity: 1;
      margin: 14px auto 0;
    }

    .lighting-divider {
      border: none;
      border-top: 1px solid #45475a;
      margin: 10px 0;
    }

    .lighting-header {
      font-size: 11px;
      color: #a6adc8;
      text-align: center;
      margin-bottom: 8px;
      letter-spacing: 0.5px;
    }

    /* Mode selector tabs for Albedo / Light */
    .mode-tabs {
      display: flex;
      gap: 4px;
      margin-bottom: 10px;
    }

    .mode-tabs button {
      flex: 1;
      padding: 5px 8px;
      border: 1px solid #45475a;
      background: #313244;
      color: #6c7086;
      border-radius: 5px;
      cursor: pointer;
      font-size: 11px;
      transition: background 0.15s, color 0.15s;
    }

    .mode-tabs button:hover {
      background: #45475a;
      color: #cdd6f4;
    }

    .mode-tabs button.tab-active {
      background: #89b4fa;
      color: #1e1e2e;
      border-color: #89b4fa;
      font-weight: 600;
    }

    /* Equation row: Albedo √ó Light = Result */
    .lighting-equation {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 6px;
      margin: 8px 0;
    }

    .lighting-swatch-wrap {
      text-align: center;
    }

    .lighting-swatch-wrap .swatch-label {
      font-size: 9px;
      color: #6c7086;
      margin-bottom: 3px;
    }

    .lighting-swatch {
      width: 48px;
      height: 48px;
      border-radius: 6px;
      border: 2px solid #45475a;
      cursor: pointer;
    }

    .lighting-swatch.read-only {
      cursor: default;
    }

    .lighting-swatch.selected {
      border-color: #89b4fa;
      box-shadow: 0 0 0 2px rgba(137, 180, 250, 0.35);
    }

    .lighting-operator {
      font-size: 18px;
      color: #6c7086;
      padding: 12px 0 0;
    }

    /* Result info in lighting panel */
    .lighting-result-info {
      margin-top: 8px;
      font: 12px 'Cascadia Code', 'Consolas', monospace;
      line-height: 1.6;
    }

    .lighting-result-info .label {
      color: #6c7086;
    }

    /* Mini a,b map for result */
    #result-ab-map {
      display: block;
      border-radius: 6px;
      margin: 8px auto 0;
    }
  </style>
</head>

<body>

  <!-- ‚îÄ‚îÄ Toolbar ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div class="toolbar">
    <button id="always-on-top-button" onclick="toggleAlwaysOnTop()">üìå Always on Top</button>
    <button onclick="pickColor()">üíß Pick Color <kbd style="opacity: 0.6; font-size: 10px">Alt+C</kbd></button>
  </div>
  <div class="toolbar">
    <button id="pick-as-display-button" onclick="togglePickAsDisplay()" title="Interpret picked colors as display-native (P3) values instead of sRGB. Enable this when picking from wide-gamut apps.">
      üé® Picker assumes: <span id="pick-space-label">sRGB</span>
    </button>
  </div>

  <!-- ‚îÄ‚îÄ 2D Color Picker (a, b axes) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div class="picker-wrap">
    <canvas id="ab-picker" width="300" height="300"></canvas>
    <span class="axis-label top">+b (yellow)</span>
    <span class="axis-label bottom">‚àíb (blue)</span>
    <span class="axis-label left">‚àía (green)</span>
    <span class="axis-label right">+a (red)</span>
  </div>

  <!-- ‚îÄ‚îÄ Lightness Slider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <canvas id="lightness-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">L: Lightness (0 ‚Üí 1)</span>

  <!-- ‚îÄ‚îÄ Chroma Slider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <canvas id="chroma-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">C: Chroma (0 ‚Üí 0.4)</span>

  <!-- ‚îÄ‚îÄ Hue Slider ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <canvas id="hue-slider" class="slider-canvas" width="300" height="28"></canvas>
  <span class="slider-label">h: Hue (0¬∞ ‚Üí 360¬∞)</span>

  <!-- ‚îÄ‚îÄ Color Info Panel ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="info">
    <!-- Preview swatch + OKLab values -->
    <div class="color-row">
      <div id="color-preview"></div>
      <div id="oklab-values"></div>
    </div>

    <!-- sRGB hex code -->
    <div class="hex-row">
      <label>sRGB:</label>
      <span class="hex-value" id="srgb-hex"></span>
      <span id="srgb-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'srgb-hex')">üìã</button>
    </div>

    <!-- Display P3 hex code -->
    <div class="hex-row">
      <label id="display-color-space-label">Display P3:</label>
      <span class="hex-value" id="display-hex"></span>
      <span id="display-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'display-hex')">üìã</button>
    </div>

    <!-- Raw CSS oklab() value -->
    <div class="hex-row">
      <label>CSS:</label>
      <span class="hex-value" id="css-oklab-value"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'css-oklab-value')">üìã</button>
    </div>
  </div>

  <!-- ‚îÄ‚îÄ Lighting Lab Toggle ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div class="toolbar" style="width:300px; margin:10px auto 0;">
    <button id="lighting-toggle-button" onclick="toggleLightingPanel()">üí° Lighting Lab</button>
  </div>

  <!-- ‚îÄ‚îÄ Lighting Lab Panel (slide-out) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ -->
  <div id="lighting-panel">
    <hr class="lighting-divider">
    <div class="lighting-header">LIGHTING LAB</div>

    <!-- Mode tabs: which color the main picker edits -->
    <div class="mode-tabs">
      <button id="tab-albedo" class="tab-active" onclick="setEditTarget('albedo')">üé® Albedo</button>
      <button id="tab-light" onclick="setEditTarget('light')">‚òÄÔ∏è Light Color</button>
    </div>

    <!-- Equation: Albedo √ó Light = Result -->
    <div class="lighting-equation">
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Albedo</div>
        <div id="swatch-albedo" class="lighting-swatch selected" onclick="setEditTarget('albedo')"></div>
      </div>
      <div class="lighting-operator">√ó</div>
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Light</div>
        <div id="swatch-light" class="lighting-swatch" onclick="setEditTarget('light')"></div>
      </div>
      <div class="lighting-operator">=</div>
      <div class="lighting-swatch-wrap">
        <div class="swatch-label">Result</div>
        <div id="swatch-result" class="lighting-swatch read-only"></div>
      </div>
    </div>

    <!-- Result mini a,b map (read-only) -->
    <canvas id="result-ab-map" width="150" height="150"></canvas>
    <span class="slider-label" style="width:150px; margin-top:4px;">Result in OKLab a,b plane</span>

    <!-- Result numeric values -->
    <div class="lighting-result-info" id="lighting-result-values"></div>
    <div class="hex-row" style="margin-top:6px">
      <label>Result:</label>
      <span class="hex-value" id="result-hex"></span>
      <span id="result-gamut-indicator"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-hex')">üìã</button>
    </div>
    <div class="hex-row">
      <label>CSS:</label>
      <span class="hex-value" id="result-css-value"></span>
      <button class="copy-button" onclick="copyToClipboard(this, 'result-css-value')">üìã</button>
    </div>
  </div>


  <script>
    const { ipcRenderer } = require('electron');


    // ================================================================
    //  COLOR MATH
    //  Conversion functions between OKLab, linear sRGB, and Display P3.
    //  All use linear-light (pre-gamma) values unless noted otherwise.
    //  Matrix coefficients from https://bottosson.github.io/posts/oklab/
    // ================================================================

    /**
     * Convert OKLab (L, a, b) ‚Üí linear sRGB (r, g, b).
     *
     * Steps:
     *   1. OKLab ‚Üí LMS (cone response, cubed-root space)
     *   2. Undo cube root to get linear LMS
     *   3. Linear LMS ‚Üí linear sRGB via 3√ó3 matrix
     */
    function oklabToLinearSRGB(L, a, b) {
      // Step 1: OKLab ‚Üí LMS (cube-root encoded)
      const lCubeRoot = L + 0.3963377774 * a + 0.2158037573 * b;
      const mCubeRoot = L - 0.1055613458 * a - 0.0638541728 * b;
      const sCubeRoot = L - 0.0894841775 * a - 1.2914855480 * b;

      // Step 2: Undo the cube root ‚Üí linear LMS
      const lLinear = lCubeRoot ** 3;
      const mLinear = mCubeRoot ** 3;
      const sLinear = sCubeRoot ** 3;

      // Step 3: LMS ‚Üí linear sRGB (3√ó3 matrix multiply)
      const red   =  4.0767416621 * lLinear - 3.3077115913 * mLinear + 0.2309699292 * sLinear;
      const green = -1.2684380046 * lLinear + 2.6097574011 * mLinear - 0.3413193965 * sLinear;
      const blue  = -0.0041960863 * lLinear - 0.7034186147 * mLinear + 1.7076147010 * sLinear;

      return [red, green, blue];
    }

    /**
     * Convert linear sRGB (r, g, b) ‚Üí linear Display P3 (r, g, b).
     *
     * This is a direct 3√ó3 matrix transform between the two RGB spaces.
     * Both share the same whitepoint (D65) but have different primaries.
     */
    function linearSRGBToLinearP3(r, g, b) {
      return [
        0.8224621209 * r + 0.1775378791 * g,
        0.0331941826 * r + 0.9668058174 * g,
        0.0170826307 * r + 0.0723974407 * g + 0.9105199286 * b
      ];
    }

    /**
     * Convert linear Display P3 (r, g, b) ‚Üí linear sRGB (r, g, b).
     *
     * This is the inverse of linearSRGBToLinearP3.
     * Used when interpreting eyedropper-picked colors as display-native P3.
     */
    function linearP3ToLinearSRGB(r, g, b) {
      return [
         1.2249401762 * r - 0.2249401762 * g,
        -0.0420569549 * r + 1.0420569549 * g,
        -0.0196375546 * r - 0.0786360236 * g + 1.0982735782 * b
      ];
    }

    // ================================================================
    //  OKLab ‚Üî OKLCH CONVERSION
    //  OKLCH is the cylindrical (polar) form of OKLab:
    //    C = chroma = sqrt(a¬≤ + b¬≤)
    //    h = hue    = atan2(b, a)  (in degrees, 0‚Äì360)
    // ================================================================

    /**
     * Convert OKLab (a, b) ‚Üí OKLCH (C, h).
     * Returns [chroma, hueDegrees].
     */
    function oklabToOklch(a, b) {
      const chroma = Math.sqrt(a * a + b * b);
      let hueDegrees = Math.atan2(b, a) * (180 / Math.PI);
      if (hueDegrees < 0) hueDegrees += 360;
      return [chroma, hueDegrees];
    }

    /**
     * Convert OKLCH (C, h) ‚Üí OKLab (a, b).
     * hue is in degrees.
     */
    function oklchToOklab(chroma, hueDegrees) {
      const hueRadians = hueDegrees * (Math.PI / 180);
      const a = chroma * Math.cos(hueRadians);
      const b = chroma * Math.sin(hueRadians);
      return [a, b];
    }


    /**
     * Convert linear sRGB (r, g, b) ‚Üí OKLab (L, a, b).
     *
     * Steps:
     *   1. Linear sRGB ‚Üí linear LMS via 3√ó3 matrix
     *   2. Cube root of LMS (perceptual compression)
     *   3. Cube-root LMS ‚Üí OKLab via 3√ó3 matrix
     */
    function linearSRGBToOKLab(r, g, b) {
      // Step 1: Linear sRGB ‚Üí linear LMS
      const lLinear = 0.4122214708 * r + 0.5363325363 * g + 0.0514459929 * b;
      const mLinear = 0.2119034982 * r + 0.6806995451 * g + 0.1073969566 * b;
      const sLinear = 0.0883024619 * r + 0.2817188376 * g + 0.6299787005 * b;

      // Step 2: Cube root (perceptual non-linearity)
      const lRoot = Math.cbrt(lLinear);
      const mRoot = Math.cbrt(mLinear);
      const sRoot = Math.cbrt(sLinear);

      // Step 3: Cube-root LMS ‚Üí OKLab
      const L =  0.2104542553 * lRoot + 0.7936177850 * mRoot - 0.0040720468 * sRoot;
      const a =  1.9779984951 * lRoot - 2.4285922050 * mRoot + 0.4505937099 * sRoot;
      const ob = 0.0259040371 * lRoot + 0.7827717662 * mRoot - 0.8086757660 * sRoot;

      return [L, a, ob];
    }


    // ================================================================
    //  GAMMA / UTILITY FUNCTIONS
    // ================================================================

    /**
     * Apply sRGB gamma encoding (linear ‚Üí gamma-encoded).
     * Input is clamped to [0, 1] before encoding.
     * The sRGB transfer function has a linear segment near zero
     * and a power curve for the rest.
     */
    function linearToGamma(linearValue) {
      const clamped = Math.max(0, Math.min(1, linearValue));
      if (clamped >= 0.0031308) {
        return 1.055 * (clamped ** (1 / 2.4)) - 0.055;
      }
      return 12.92 * clamped;
    }

    /**
     * Remove sRGB gamma encoding (gamma-encoded ‚Üí linear).
     * Inverse of linearToGamma().
     */
    function gammaToLinear(gammaValue) {
      if (gammaValue >= 0.04045) {
        return ((gammaValue + 0.055) / 1.055) ** 2.4;
      }
      return gammaValue / 12.92;
    }

    /** Clamp a value to the [0, 1] range. */
    function clamp01(value) {
      return Math.max(0, Math.min(1, value));
    }

    /**
     * Check whether (r, g, b) values fall within the [0, 1] gamut.
     * A small tolerance (¬±0.0005) is used to avoid false negatives
     * from floating-point rounding in the matrix conversions.
     */
    function isInGamut(r, g, b) {
      const TOLERANCE = 5e-4;
      return (
        r >= -TOLERANCE && r <= 1 + TOLERANCE &&
        g >= -TOLERANCE && g <= 1 + TOLERANCE &&
        b >= -TOLERANCE && b <= 1 + TOLERANCE
      );
    }

    /**
     * Convert gamma-encoded (r, g, b) in [0,1] to a hex color string.
     * Example: (1, 0.5, 0) ‚Üí "#ff8000"
     */
    function rgbToHex(r, g, b) {
      const toByteHex = (value) =>
        Math.round(clamp01(value) * 255)
          .toString(16)
          .padStart(2, '0');
      return '#' + toByteHex(r) + toByteHex(g) + toByteHex(b);
    }

    /** Convert a linear channel value to a 0‚Äì255 byte for ImageData. */
    function linearToColorByte(linearValue) {
      return Math.round(linearToGamma(linearValue) * 255);
    }


    // ================================================================
    //  APPLICATION STATE
    // ================================================================

    /** Current OKLab color components */
    let currentL = 0.7;   // Lightness: 0 (black) to 1 (white)
    let currentA = 0.0;   // Green‚ÄìRed axis: roughly ‚àí0.4 to +0.4
    let currentB = 0.0;   // Blue‚ÄìYellow axis: roughly ‚àí0.4 to +0.4

    /** Whether the window is set to always-on-top */
    let isAlwaysOnTop = true;

    /** Whether to interpret eyedropper-picked colors as display-native (P3) */
    let interpretPickedAsDisplay = true;

    /** Lighting Lab state */
    let isLightingOpen = false;
    let editTarget = 'albedo';  // 'albedo' or 'light'

    // Albedo color (OKLab) ‚Äî initialized to current picker color
    let albedoL = 0.7, albedoA = 0.0, albedoB = 0.0;
    // Light color (OKLab) ‚Äî initialized to white (neutral)
    let lightL = 1.0, lightA = 0.0, lightB = 0.0;

    // ‚îÄ‚îÄ Color Selection History ‚îÄ‚îÄ
    // Three independent history stacks: main picker, albedo, and light.
    // Each entry is [L, a, b]. Position tracks where we are in the list.
    const historyMain   = { entries: [[0.7, 0.0, 0.0]], pos: 0 };
    const historyAlbedo = { entries: [[0.7, 0.0, 0.0]], pos: 0 };
    const historyLight  = { entries: [[1.0, 0.0, 0.0]], pos: 0 };
    const MAX_HISTORY = 200;

    /** Canvas dimensions & OKLab axis range */
    const PICKER_SIZE = 300;         // Width & height of the a,b picker (px)
    const AB_RANGE = 0.4;            // a,b axis extends from -0.4 to +0.4
    const SLIDER_HEIGHT = 28;        // Height of each slider (px)
    const CHROMA_MAX = 0.4;            // Maximum chroma value for the slider


    // ================================================================
    //  CANVAS SETUP
    //  If the browser supports Display P3 canvases (wide gamut), we use
    //  that color space so colors outside sRGB can be shown accurately
    //  on a wide-gamut monitor. Otherwise we fall back to sRGB.
    // ================================================================

    const abPickerCanvas = document.getElementById('ab-picker');
    const lightnessSliderCanvas = document.getElementById('lightness-slider');
    const chromaSliderCanvas = document.getElementById('chroma-slider');
    const hueSliderCanvas = document.getElementById('hue-slider');

    // Detect whether the display supports the P3 wide color gamut.
    // If it does, we use a 'display-p3' canvas so colors outside sRGB render accurately.
    const isDisplayP3Supported = window.matchMedia('(color-gamut: p3)').matches;
    const canvasColorSpace = isDisplayP3Supported ? 'display-p3' : 'srgb';
    const canvasOptions = { colorSpace: canvasColorSpace };
    const abPickerContext = abPickerCanvas.getContext('2d', canvasOptions);
    const lightnessContext = lightnessSliderCanvas.getContext('2d', canvasOptions);
    const chromaContext = chromaSliderCanvas.getContext('2d', canvasOptions);
    const hueContext = hueSliderCanvas.getContext('2d', canvasOptions);

    // Result mini a,b map canvas (150√ó150)
    const RESULT_MAP_SIZE = 150;
    const resultABCanvas = document.getElementById('result-ab-map');
    const resultABContext = resultABCanvas.getContext('2d', canvasOptions);

    // Update the display color space label if P3 is not available
    if (!isDisplayP3Supported) {
      document.getElementById('display-color-space-label').textContent = 'sRGB (disp):';
    }


    // ================================================================
    //  GAMUT HELPERS
    //  Functions for checking and clamping colors to the display gamut.
    //  Uses P3 if the display supports it, otherwise sRGB.
    // ================================================================

    /**
     * Check whether an OKLab color falls within the display's color gamut.
     */
    function isInDisplayGamut(L, a, b) {
      const [linearR, linearG, linearB] = oklabToLinearSRGB(L, a, b);
      if (isDisplayP3Supported) {
        const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
        return isInGamut(p3R, p3G, p3B);
      }
      return isInGamut(linearR, linearG, linearB);
    }

    /**
     * Binary-search for the maximum chroma that keeps the color in the
     * display gamut at a given lightness and hue angle.
     * @returns {number} Maximum in-gamut chroma
     */
    function findMaxInGamutChroma(L, hueDegrees, maxSearch = CHROMA_MAX) {
      const [aHi, bHi] = oklchToOklab(maxSearch, hueDegrees);
      if (isInDisplayGamut(L, aHi, bHi)) return maxSearch;
      let lo = 0, hi = maxSearch;
      for (let i = 0; i < 20; i++) {
        const mid = (lo + hi) / 2;
        const [a, b] = oklchToOklab(mid, hueDegrees);
        if (isInDisplayGamut(L, a, b)) { lo = mid; } else { hi = mid; }
      }
      return lo;
    }

    /**
     * Clamp an OKLab color to the display gamut by reducing chroma
     * while preserving lightness and hue.
     * @returns {[number, number]} Clamped [a, b] values
     */
    function clampToDisplayGamut(L, a, b) {
      if (isInDisplayGamut(L, a, b)) return [a, b];
      const [chroma, hue] = oklabToOklch(a, b);
      const maxChroma = findMaxInGamutChroma(L, hue, chroma);
      return oklchToOklab(maxChroma, hue);
    }


    // ================================================================
    //  RENDERING: a,b PICKER
    //  Draws a 300√ó300 image where each pixel represents an OKLab color
    //  at the current lightness (L). The x-axis maps to 'a' (green‚Üíred),
    //  and the y-axis maps to 'b' (blue‚Üíyellow, top = +b).
    // ================================================================

    /** Cached ImageData for the a,b picker background */
    let abPickerImageData = null;

    /**
     * Compute the pixel colors for every (a, b) combination at the
     * current lightness value and store them in abPickerImageData.
     */
    function renderABPickerColors() {
      abPickerImageData = abPickerContext.createImageData(PICKER_SIZE, PICKER_SIZE);
      const pixels = abPickerImageData.data;
      const step = (2 * AB_RANGE) / (PICKER_SIZE - 1);

      for (let y = 0; y < PICKER_SIZE; y++) {
        // Top of canvas = +AB_RANGE (positive b), bottom = -AB_RANGE
        const bValue = AB_RANGE - y * step;

        for (let x = 0; x < PICKER_SIZE; x++) {
          // Left of canvas = -AB_RANGE (negative a), right = +AB_RANGE
          const aValue = -AB_RANGE + x * step;

          // Convert this OKLab color to linear sRGB
          const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, aValue, bValue);

          // Calculate the pixel offset in the ImageData buffer (4 bytes per pixel: RGBA)
          const pixelIndex = (y * PICKER_SIZE + x) * 4;

          let byteR, byteG, byteB, inGamut;
          if (isDisplayP3Supported) {
            const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
            inGamut = isInGamut(p3R, p3G, p3B);
            byteR = linearToColorByte(p3R);
            byteG = linearToColorByte(p3G);
            byteB = linearToColorByte(p3B);
          } else {
            inGamut = isInGamut(linearR, linearG, linearB);
            byteR = linearToColorByte(linearR);
            byteG = linearToColorByte(linearG);
            byteB = linearToColorByte(linearB);
          }

          // Darken out-of-gamut pixels with diagonal stripe pattern
          if (!inGamut) {
            byteR = Math.round(byteR * 0.15);
            byteG = Math.round(byteG * 0.15);
            byteB = Math.round(byteB * 0.15);
            if ((x + y) % 6 < 1) {
              byteR = Math.min(255, byteR + 35);
              byteG = Math.min(255, byteG + 35);
              byteB = Math.min(255, byteB + 35);
            }
          }

          pixels[pixelIndex]     = byteR;
          pixels[pixelIndex + 1] = byteG;
          pixels[pixelIndex + 2] = byteB;
          pixels[pixelIndex + 3] = 255; // Fully opaque
        }
      }
    }

    /**
     * Draw the a,b picker: blit the cached color image, then draw
     * a crosshair circle at the currently selected (a, b) position.
     */
    function drawABPicker() {
      if (!abPickerImageData) return;

      // Draw the pre-computed color field
      abPickerContext.putImageData(abPickerImageData, 0, 0);

      // Convert current (a, b) values to canvas pixel coordinates
      const cursorX = ((currentA + AB_RANGE) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);
      const cursorY = ((AB_RANGE - currentB) / (2 * AB_RANGE)) * (PICKER_SIZE - 1);

      // Use contrasting colors for the crosshair depending on lightness
      const isDark = currentL > 0.5;

      // Inner ring (strong contrast)
      abPickerContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      abPickerContext.lineWidth = 2.5;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 7, 0, 2 * Math.PI);
      abPickerContext.stroke();

      // Outer ring (subtle halo for visibility)
      abPickerContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      abPickerContext.lineWidth = 1;
      abPickerContext.beginPath();
      abPickerContext.arc(cursorX, cursorY, 9, 0, 2 * Math.PI);
      abPickerContext.stroke();
    }


    // ================================================================
    //  RENDERING: LIGHTNESS SLIDER
    //  A horizontal bar where each pixel column represents a different
    //  lightness (L) value at the current (a, b). Left = 0, right = 1.
    // ================================================================

    /** Cached ImageData for the lightness slider background */
    let lightnessImageData = null;

    /**
     * Compute the pixel colors for the lightness slider at the
     * current (a, b) values.
     */
    function renderLightnessSliderColors() {
      lightnessImageData = lightnessContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = lightnessImageData.data;

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to lightness value [0, 1]
        const lightnessValue = x / (PICKER_SIZE - 1);

        // Convert this OKLab color to linear sRGB
        const [linearR, linearG, linearB] = oklabToLinearSRGB(lightnessValue, currentA, currentB);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the lightness slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected L value.
     */
    function drawLightnessSlider() {
      if (!lightnessImageData) return;

      // Draw the pre-computed gradient
      lightnessContext.putImageData(lightnessImageData, 0, 0);

      // Convert current L to a pixel x-coordinate
      const indicatorX = currentL * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      lightnessContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      lightnessContext.lineWidth = 3;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX, 0);
      lightnessContext.lineTo(indicatorX, SLIDER_HEIGHT);
      lightnessContext.stroke();

      // Flanking lines for contrast
      lightnessContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      lightnessContext.lineWidth = 1;
      lightnessContext.beginPath();
      lightnessContext.moveTo(indicatorX - 2, 0);
      lightnessContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      lightnessContext.moveTo(indicatorX + 2, 0);
      lightnessContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      lightnessContext.stroke();
    }


    // ================================================================
    //  RENDERING: CHROMA SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  chroma (C) value, keeping the current L and hue constant.
    //  Left = 0, right = CHROMA_MAX.
    // ================================================================

    /** Cached ImageData for the chroma slider background */
    let chromaImageData = null;

    /**
     * Compute the pixel colors for the chroma slider at the
     * current lightness and hue.
     */
    function renderChromaSliderColors() {
      chromaImageData = chromaContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = chromaImageData.data;
      const [, currentHue] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to chroma value [0, CHROMA_MAX]
        const chromaValue = (x / (PICKER_SIZE - 1)) * CHROMA_MAX;

        // Convert OKLCH ‚Üí OKLab ‚Üí linear sRGB
        const [a, b] = oklchToOklab(chromaValue, currentHue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the chroma slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected chroma.
     */
    function drawChromaSlider() {
      if (!chromaImageData) return;

      chromaContext.putImageData(chromaImageData, 0, 0);

      // Compute current chroma and map to pixel position
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentChroma / CHROMA_MAX) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      chromaContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      chromaContext.lineWidth = 3;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX, 0);
      chromaContext.lineTo(indicatorX, SLIDER_HEIGHT);
      chromaContext.stroke();

      // Flanking lines for contrast
      chromaContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      chromaContext.lineWidth = 1;
      chromaContext.beginPath();
      chromaContext.moveTo(indicatorX - 2, 0);
      chromaContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      chromaContext.moveTo(indicatorX + 2, 0);
      chromaContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      chromaContext.stroke();
    }


    // ================================================================
    //  RENDERING: HUE SLIDER
    //  Horizontal bar where each column shows the color at a different
    //  hue angle, keeping the current L and chroma constant.
    //  Left = 0¬∞, right = 360¬∞.
    // ================================================================

    /** Cached ImageData for the hue slider background */
    let hueImageData = null;

    /**
     * Compute the pixel colors for the hue slider at the
     * current lightness and chroma.
     */
    function renderHueSliderColors() {
      hueImageData = hueContext.createImageData(PICKER_SIZE, SLIDER_HEIGHT);
      const pixels = hueImageData.data;
      const [currentChroma] = oklabToOklch(currentA, currentB);

      for (let x = 0; x < PICKER_SIZE; x++) {
        // Map x position to hue value [0, 360)
        const hueValue = (x / (PICKER_SIZE - 1)) * 360;

        // Convert OKLCH ‚Üí OKLab ‚Üí linear sRGB
        const [a, b] = oklchToOklab(currentChroma, hueValue);
        const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, a, b);

        // Determine the display byte values and check gamut
        let byteR, byteG, byteB, inGamut;
        if (isDisplayP3Supported) {
          const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
          inGamut = isInGamut(p3R, p3G, p3B);
          byteR = linearToColorByte(p3R);
          byteG = linearToColorByte(p3G);
          byteB = linearToColorByte(p3B);
        } else {
          inGamut = isInGamut(linearR, linearG, linearB);
          byteR = linearToColorByte(linearR);
          byteG = linearToColorByte(linearG);
          byteB = linearToColorByte(linearB);
        }

        // Darken out-of-gamut columns
        if (!inGamut) {
          byteR = Math.round(byteR * 0.15);
          byteG = Math.round(byteG * 0.15);
          byteB = Math.round(byteB * 0.15);
        }

        // Fill column (with diagonal stripe for out-of-gamut)
        for (let y = 0; y < SLIDER_HEIGHT; y++) {
          const pixelIndex = (y * PICKER_SIZE + x) * 4;
          if (!inGamut && (x + y) % 6 < 1) {
            pixels[pixelIndex]     = Math.min(255, byteR + 35);
            pixels[pixelIndex + 1] = Math.min(255, byteG + 35);
            pixels[pixelIndex + 2] = Math.min(255, byteB + 35);
          } else {
            pixels[pixelIndex]     = byteR;
            pixels[pixelIndex + 1] = byteG;
            pixels[pixelIndex + 2] = byteB;
          }
          pixels[pixelIndex + 3] = 255;
        }
      }
    }

    /**
     * Draw the hue slider: blit the cached gradient, then draw
     * a vertical line indicator at the currently selected hue.
     */
    function drawHueSlider() {
      if (!hueImageData) return;

      hueContext.putImageData(hueImageData, 0, 0);

      // Compute current hue and map to pixel position
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const indicatorX = (currentHue / 360) * (PICKER_SIZE - 1);
      const isDark = currentL > 0.5;

      // Main indicator line
      hueContext.strokeStyle = isDark ? 'rgba(0, 0, 0, 0.85)' : 'rgba(255, 255, 255, 0.85)';
      hueContext.lineWidth = 3;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX, 0);
      hueContext.lineTo(indicatorX, SLIDER_HEIGHT);
      hueContext.stroke();

      // Flanking lines for contrast
      hueContext.strokeStyle = isDark ? 'rgba(255, 255, 255, 0.5)' : 'rgba(0, 0, 0, 0.5)';
      hueContext.lineWidth = 1;
      hueContext.beginPath();
      hueContext.moveTo(indicatorX - 2, 0);
      hueContext.lineTo(indicatorX - 2, SLIDER_HEIGHT);
      hueContext.moveTo(indicatorX + 2, 0);
      hueContext.lineTo(indicatorX + 2, SLIDER_HEIGHT);
      hueContext.stroke();
    }


    // ================================================================
    //  INFO PANEL
    //  Updates the color preview swatch, OKLab/OKLCH readout, hex codes,
    //  and gamut indicators.
    // ================================================================

    function updateInfoPanel() {
      // Convert current OKLab ‚Üí linear sRGB
      const [linearR, linearG, linearB] = oklabToLinearSRGB(currentL, currentA, currentB);

      // Check sRGB gamut and compute hex
      const srgbInGamut = isInGamut(linearR, linearG, linearB);
      const srgbHex = rgbToHex(
        linearToGamma(linearR),
        linearToGamma(linearG),
        linearToGamma(linearB)
      );

      // Convert to Display P3, check gamut, compute hex
      const [p3R, p3G, p3B] = linearSRGBToLinearP3(linearR, linearG, linearB);
      const displayInGamut = isInGamut(p3R, p3G, p3B);
      const displayHex = rgbToHex(
        linearToGamma(p3R),
        linearToGamma(p3G),
        linearToGamma(p3B)
      );

      // Compute OKLCH values for display
      const [currentChroma, currentHue] = oklabToOklch(currentA, currentB);

      // Update the OKLab + OKLCH numeric readout
      document.getElementById('oklab-values').innerHTML =
        `L: <b>${currentL.toFixed(3)}</b>&ensp;` +
        `a: <b>${currentA.toFixed(3)}</b>&ensp;` +
        `b: <b>${currentB.toFixed(3)}</b><br>` +
        `C: <b>${currentChroma.toFixed(3)}</b>&ensp;` +
        `h: <b>${currentHue.toFixed(1)}¬∞</b>`;

      // Update the preview swatch using native CSS oklab() for correct rendering
      document.getElementById('color-preview').style.background =
        `oklab(${currentL} ${currentA} ${currentB})`;

      // Update sRGB hex and gamut indicator
      document.getElementById('srgb-hex').textContent = srgbHex;
      document.getElementById('srgb-gamut-indicator').innerHTML = srgbInGamut
        ? '<span class="in-gamut" title="In sRGB gamut">‚úì</span>'
        : '<span class="out-of-gamut" title="Out of sRGB gamut">‚úó out of gamut</span>';

      // Update display color space hex and gamut indicator
      document.getElementById('display-hex').textContent = displayHex;
      document.getElementById('display-gamut-indicator').innerHTML = displayInGamut
        ? '<span class="in-gamut" title="In Display P3 gamut">‚úì</span>'
        : '<span class="out-of-gamut" title="Out of Display P3 gamut">‚úó out of gamut</span>';

      // Update the raw CSS oklab() value
      document.getElementById('css-oklab-value').textContent =
        `oklab(${currentL.toFixed(3)} ${currentA.toFixed(3)} ${currentB.toFixed(3)})`;
    }


    // ================================================================
    //  LIGHTING LAB
    //  Computes result = albedo √ó light in linear sRGB space.
    //  Shows the result on a read-only mini a,b map and info readout.
    // ================================================================

    /**
     * Compute the lit color: result = albedo √ó light (component-wise
     * multiply in linear sRGB). Returns OKLab [L, a, b].
     */
    function computeLitColor() {
      const [albR, albG, albB] = oklabToLinearSRGB(albedoL, albedoA, albedoB);
      const [litR, litG, litB] = oklabToLinearSRGB(lightL, lightA, lightB);

      // Component-wise multiplication in linear light
      const resultR = albR * litR;
      const resultG = albG * litG;
      const resultB = albB * litB;

      return linearSRGBToOKLab(resultR, resultG, resultB);
    }

    /** Cached ImageData for the result mini a,b map */
    let resultABImageData = null;

    /**
     * Render the result mini a,b map. Shows the color field at the
     * result's lightness, with a marker at the result (a, b).
     */
    function renderResultABMap() {
      const [resL, resA, resB] = computeLitColor();

      resultABImageData = resultABContext.createImageData(RESULT_MAP_SIZE, RESULT_MAP_SIZE);
      const pixels = resultABImageData.data;
      const step = (2 * AB_RANGE) / (RESULT_MAP_SIZE - 1);

      for (let y = 0; y < RESULT_MAP_SIZE; y++) {
        const bVal = AB_RANGE - y * step;
        for (let x = 0; x < RESULT_MAP_SIZE; x++) {
          const aVal = -AB_RANGE + x * step;
          const [linR, linG, linB] = oklabToLinearSRGB(resL, aVal, bVal);
          const idx = (y * RESULT_MAP_SIZE + x) * 4;

          let bR, bG, bB, inGamut;
          if (isDisplayP3Supported) {
            const [p3R, p3G, p3B] = linearSRGBToLinearP3(linR, linG, linB);
            inGamut = isInGamut(p3R, p3G, p3B);
            bR = linearToColorByte(p3R);
            bG = linearToColorByte(p3G);
            bB = linearToColorByte(p3B);
          } else {
            inGamut = isInGamut(linR, linG, linB);
            bR = linearToColorByte(linR);
            bG = linearToColorByte(linG);
            bB = linearToColorByte(linB);
          }

          if (!inGamut) {
            bR = Math.round(bR * 0.15);
            bG = Math.round(bG * 0.15);
            bB = Math.round(bB * 0.15);
            if ((x + y) % 6 < 1) {
              bR = Math.min(255, bR + 35);
              bG = Math.min(255, bG + 35);
              bB = Math.min(255, bB + 35);
            }
          }

          pixels[idx]     = bR;
          pixels[idx + 1] = bG;
          pixels[idx + 2] = bB;
          pixels[idx + 3] = 255;
        }
      }

      resultABContext.putImageData(resultABImageData, 0, 0);

      // Draw crosshair at the result (a, b) position
      const cx = ((resA + AB_RANGE) / (2 * AB_RANGE)) * (RESULT_MAP_SIZE - 1);
      const cy = ((AB_RANGE - resB) / (2 * AB_RANGE)) * (RESULT_MAP_SIZE - 1);
      const isDark = resL > 0.5;

      resultABContext.strokeStyle = isDark ? 'rgba(0,0,0,0.85)' : 'rgba(255,255,255,0.85)';
      resultABContext.lineWidth = 2;
      resultABContext.beginPath();
      resultABContext.arc(cx, cy, 5, 0, 2 * Math.PI);
      resultABContext.stroke();

      resultABContext.strokeStyle = isDark ? 'rgba(255,255,255,0.5)' : 'rgba(0,0,0,0.5)';
      resultABContext.lineWidth = 1;
      resultABContext.beginPath();
      resultABContext.arc(cx, cy, 7, 0, 2 * Math.PI);
      resultABContext.stroke();
    }

    /**
     * Update the lighting panel swatches and result info.
     */
    function updateLightingPanel() {
      if (!isLightingOpen) return;

      // Update swatches using CSS oklab()
      document.getElementById('swatch-albedo').style.background =
        `oklab(${albedoL} ${albedoA} ${albedoB})`;
      document.getElementById('swatch-light').style.background =
        `oklab(${lightL} ${lightA} ${lightB})`;

      const [resL, resA, resB] = computeLitColor();
      document.getElementById('swatch-result').style.background =
        `oklab(${resL} ${resA} ${resB})`;

      // Result numeric readout
      const [resChroma, resHue] = oklabToOklch(resA, resB);
      document.getElementById('lighting-result-values').innerHTML =
        `<span class="label">L:</span> <b>${resL.toFixed(3)}</b>&ensp;` +
        `<span class="label">a:</span> <b>${resA.toFixed(3)}</b>&ensp;` +
        `<span class="label">b:</span> <b>${resB.toFixed(3)}</b><br>` +
        `<span class="label">C:</span> <b>${resChroma.toFixed(3)}</b>&ensp;` +
        `<span class="label">h:</span> <b>${resHue.toFixed(1)}¬∞</b>`;

      // Result hex
      const [linR, linG, linB] = oklabToLinearSRGB(resL, resA, resB);
      const resultInGamut = isInGamut(linR, linG, linB);
      const resultHex = rgbToHex(
        linearToGamma(linR), linearToGamma(linG), linearToGamma(linB)
      );
      document.getElementById('result-hex').textContent = resultHex;
      document.getElementById('result-gamut-indicator').innerHTML = resultInGamut
        ? '<span class="in-gamut" title="In sRGB gamut">‚úì</span>'
        : '<span class="out-of-gamut" title="Out of sRGB gamut">‚úó</span>';
      document.getElementById('result-css-value').textContent =
        `oklab(${resL.toFixed(3)} ${resA.toFixed(3)} ${resB.toFixed(3)})`;

      // Render the result mini a,b map
      renderResultABMap();
    }


    // ================================================================
    //  RENDER ORCHESTRATION
    //  Different interactions require recomputing different parts:
    //  - renderAll: recompute everything (initial load, color pick)
    //  - onABChanged: a or b changed ‚Üí recompute L slider, redraw both
    //  - onLightnessChanged: L changed ‚Üí recompute a,b field, redraw both
    // ================================================================

    /** Helper: redraw all slider indicators + info (no pixel recomputation) */
    function drawAllSliders() {
      drawLightnessSlider();
      drawChromaSlider();
      drawHueSlider();
    }

    /** Helper: recompute all slider gradients */
    function renderAllSliderColors() {
      renderLightnessSliderColors();
      renderChromaSliderColors();
      renderHueSliderColors();
    }

    function renderAll() {
      syncPickerToEditTarget();
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      updateLightingPanel();
    }

    function onABChanged() {
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onLightnessChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onChromaChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    function onHueChanged() {
      renderABPickerColors();
      renderAllSliderColors();
      drawABPicker();
      drawAllSliders();
      updateInfoPanel();
      writePickerToEditTarget();
      updateLightingPanel();
    }

    /**
     * Write the current picker state (currentL/A/B) into the active
     * edit target (albedo or light). Only acts when Lighting Lab is open.
     */
    function writePickerToEditTarget() {
      if (!isLightingOpen) return;
      if (editTarget === 'albedo') {
        albedoL = currentL;
        albedoA = currentA;
        albedoB = currentB;
      } else {
        lightL = currentL;
        lightA = currentA;
        lightB = currentB;
      }
    }

    /**
     * Load the active edit target's color into the picker state
     * and re-render.
     */
    function syncPickerToEditTarget() {
      if (!isLightingOpen) return;
      if (editTarget === 'albedo') {
        currentL = albedoL;
        currentA = albedoA;
        currentB = albedoB;
      } else {
        currentL = lightL;
        currentA = lightA;
        currentB = lightB;
      }
    }

    /**
     * Switch the main picker to edit albedo or light color.
     */
    function setEditTarget(target) {
      editTarget = target;
      document.getElementById('tab-albedo').classList.toggle('tab-active', target === 'albedo');
      document.getElementById('tab-light').classList.toggle('tab-active', target === 'light');
      document.getElementById('swatch-albedo').classList.toggle('selected', target === 'albedo');
      document.getElementById('swatch-light').classList.toggle('selected', target === 'light');
      syncPickerToEditTarget();
      renderAll();
    }

    /**
     * Toggle the Lighting Lab panel open/closed.
     */
    function toggleLightingPanel() {
      isLightingOpen = !isLightingOpen;
      document.getElementById('lighting-panel').classList.toggle('open', isLightingOpen);
      document.getElementById('lighting-toggle-button').classList.toggle('active', isLightingOpen);
      if (isLightingOpen) {
        // Snapshot current picker color as albedo
        albedoL = currentL;
        albedoA = currentA;
        albedoB = currentB;
        editTarget = 'albedo';
        document.getElementById('tab-albedo').classList.add('tab-active');
        document.getElementById('tab-light').classList.remove('tab-active');
        document.getElementById('swatch-albedo').classList.add('selected');
        document.getElementById('swatch-light').classList.remove('selected');
        updateLightingPanel();
      }
    }


    // ================================================================
    //  POINTER INTERACTION
    //  Handles click-and-drag on both the a,b picker and the L slider.
    //  Uses requestAnimationFrame to throttle redraws during drag.
    // ================================================================

    let isDraggingAB = false;
    let isDraggingLightness = false;
    let isDraggingChroma = false;
    let isDraggingHue = false;
    let isAnimationFramePending = false;

    /**
     * Read pointer position over the a,b picker canvas and update
     * currentA and currentB accordingly.
     */
    function updateABFromPointer(event) {
      const rect = abPickerCanvas.getBoundingClientRect();
      const normalizedX = clamp01((event.clientX - rect.left) / rect.width);
      const normalizedY = clamp01((event.clientY - rect.top) / rect.height);

      // Map normalized coordinates to OKLab a,b range
      const targetA = normalizedX * 2 * AB_RANGE - AB_RANGE;  // left=-0.4, right=+0.4
      const targetB = AB_RANGE - normalizedY * 2 * AB_RANGE;  // top=+0.4, bottom=-0.4

      // Clamp to display gamut by reducing chroma (preserving hue)
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the lightness slider and update
     * currentL accordingly.
     */
    function updateLightnessFromPointer(event) {
      const rect = lightnessSliderCanvas.getBoundingClientRect();
      currentL = clamp01((event.clientX - rect.left) / rect.width);  // left=0, right=1
      // Clamp a,b to stay in gamut at the new lightness
      [currentA, currentB] = clampToDisplayGamut(currentL, currentA, currentB);
    }

    /**
     * Read pointer position over the chroma slider and update
     * currentA and currentB (keeping hue constant).
     */
    function updateChromaFromPointer(event) {
      const rect = chromaSliderCanvas.getBoundingClientRect();
      const newChroma = clamp01((event.clientX - rect.left) / rect.width) * CHROMA_MAX;
      const [, currentHue] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(newChroma, currentHue);
      // Clamp chroma to gamut boundary
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    /**
     * Read pointer position over the hue slider and update
     * currentA and currentB (keeping chroma constant).
     */
    function updateHueFromPointer(event) {
      const rect = hueSliderCanvas.getBoundingClientRect();
      const newHue = clamp01((event.clientX - rect.left) / rect.width) * 360;
      const [currentChroma] = oklabToOklch(currentA, currentB);
      const [targetA, targetB] = oklchToOklab(currentChroma, newHue);
      // Clamp to gamut at new hue by reducing chroma if needed
      [currentA, currentB] = clampToDisplayGamut(currentL, targetA, targetB);
    }

    // ‚îÄ‚îÄ Pointer Down: begin drag ‚îÄ‚îÄ
    abPickerCanvas.addEventListener('pointerdown', (event) => {
      isDraggingAB = true;
      abPickerCanvas.setPointerCapture(event.pointerId);
      updateABFromPointer(event);
      onABChanged();
    });

    lightnessSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingLightness = true;
      lightnessSliderCanvas.setPointerCapture(event.pointerId);
      updateLightnessFromPointer(event);
      onLightnessChanged();
    });

    chromaSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingChroma = true;
      chromaSliderCanvas.setPointerCapture(event.pointerId);
      updateChromaFromPointer(event);
      onChromaChanged();
    });

    hueSliderCanvas.addEventListener('pointerdown', (event) => {
      isDraggingHue = true;
      hueSliderCanvas.setPointerCapture(event.pointerId);
      updateHueFromPointer(event);
      onHueChanged();
    });

    // ‚îÄ‚îÄ Pointer Move: update during drag (throttled) ‚îÄ‚îÄ
    window.addEventListener('pointermove', (event) => {
      if (!isDraggingAB && !isDraggingLightness && !isDraggingChroma && !isDraggingHue) return;

      // Throttle to one update per animation frame to avoid jank
      if (isAnimationFramePending) return;
      isAnimationFramePending = true;

      requestAnimationFrame(() => {
        isAnimationFramePending = false;

        if (isDraggingAB) {
          updateABFromPointer(event);
          onABChanged();
        }
        if (isDraggingLightness) {
          updateLightnessFromPointer(event);
          onLightnessChanged();
        }
        if (isDraggingChroma) {
          updateChromaFromPointer(event);
          onChromaChanged();
        }
        if (isDraggingHue) {
          updateHueFromPointer(event);
          onHueChanged();
        }
      });
    });

    // ‚îÄ‚îÄ Pointer Up: end drag ‚Üí commit to history ‚îÄ‚îÄ
    window.addEventListener('pointerup', () => {
      const wasDragging = isDraggingAB || isDraggingLightness || isDraggingChroma || isDraggingHue;
      isDraggingAB = false;
      isDraggingLightness = false;
      isDraggingChroma = false;
      isDraggingHue = false;
      if (wasDragging) {
        pushColorToHistory();
      }
    });


    // ================================================================
    //  ALWAYS ON TOP
    //  Toggles the Electron window's always-on-top state via IPC.
    // ================================================================

    function toggleAlwaysOnTop() {
      isAlwaysOnTop = !isAlwaysOnTop;
      ipcRenderer.send('set-aot', isAlwaysOnTop);
      document.getElementById('always-on-top-button').classList.toggle('active', isAlwaysOnTop);
    }


    // ================================================================
    //  EYEDROPPER COLOR PICKER
    //  Uses the EyeDropper API to sample a color from anywhere on screen.
    //  The sampled sRGB hex is converted back to OKLab to update the UI.
    // ================================================================

    async function pickColor() {
      try {
        const result = await new EyeDropper().open();
        const hex = result.sRGBHex; // e.g. "#ff8040"

        // Parse hex ‚Üí gamma-encoded channel values [0, 1]
        const gammaR = parseInt(hex.slice(1, 3), 16) / 255;
        const gammaG = parseInt(hex.slice(3, 5), 16) / 255;
        const gammaB = parseInt(hex.slice(5, 7), 16) / 255;

        // Decode gamma (sRGB and P3 share the same transfer function)
        let linearR = gammaToLinear(gammaR);
        let linearG = gammaToLinear(gammaG);
        let linearB = gammaToLinear(gammaB);

        // If the user wants to interpret picked colors as display-native P3,
        // convert from linear P3 ‚Üí linear sRGB before going to OKLab.
        // This compensates for the EyeDropper API returning raw framebuffer
        // values as "sRGB" when they're really in the display's color space.
        if (interpretPickedAsDisplay && isDisplayP3Supported) {
          [linearR, linearG, linearB] = linearP3ToLinearSRGB(linearR, linearG, linearB);
        }

        // Convert linear sRGB ‚Üí OKLab
        const [L, a, b] = linearSRGBToOKLab(linearR, linearG, linearB);

        currentL = L;
        currentA = a;
        currentB = b;
        writePickerToEditTarget();
        pushColorToHistory();
        renderAll();
      } catch (error) {
        // User cancelled the eyedropper ‚Äî no action needed
      }
    }


    // ================================================================
    //  EYEDROPPER COLOR SPACE TOGGLE
    //  The EyeDropper API always returns sRGB hex, but on wide-gamut
    //  displays the raw pixel values may actually be in Display P3.
    //  This toggle lets the user choose the correct interpretation.
    // ================================================================

    function togglePickAsDisplay() {
      interpretPickedAsDisplay = !interpretPickedAsDisplay;
      const btn = document.getElementById('pick-as-display-button');
      const label = document.getElementById('pick-space-label');
      if (interpretPickedAsDisplay) {
        btn.classList.add('active-warn');
        label.textContent = isDisplayP3Supported ? 'Display P3' : 'sRGB (no P3)';
      } else {
        btn.classList.remove('active-warn');
        label.textContent = 'sRGB';
      }
    }


    // ================================================================
    //  COPY TO CLIPBOARD
    //  Copies the text content of a given element to the clipboard
    //  and briefly shows a checkmark on the button for feedback.
    // ================================================================

    async function copyToClipboard(button, elementId) {
      const text = document.getElementById(elementId).textContent;
      await navigator.clipboard.writeText(text);

      // Show brief "copied" feedback
      const originalText = button.textContent;
      button.textContent = '‚úì';
      setTimeout(() => {
        button.textContent = originalText;
      }, 700);
    }


    // ================================================================
    //  INITIALIZATION
    // ================================================================

    // Apply default states to UI
    ipcRenderer.send('set-aot', true);
    document.getElementById('always-on-top-button').classList.add('active');
    if (isDisplayP3Supported) {
      document.getElementById('pick-as-display-button').classList.add('active-warn');
      document.getElementById('pick-space-label').textContent = 'Display P3';
    }

    renderAll();


    // ================================================================
    //  COLOR SELECTION HISTORY
    //  Independent history stacks for main picker, albedo, and light.
    //  Ctrl+Z navigates backward, Ctrl+Shift+Z forward.
    //  New selections always append to the top; forward history is
    //  preserved (this is navigation, not undo/redo).
    // ================================================================

    /**
     * Get the active history stack based on the current mode.
     */
    function getActiveHistory() {
      if (!isLightingOpen) return historyMain;
      return editTarget === 'albedo' ? historyAlbedo : historyLight;
    }

    /**
     * Push the current color onto the active history stack.
     * Moves position to the new top entry.
     */
    function pushColorToHistory() {
      const h = getActiveHistory();
      const last = h.entries[h.entries.length - 1];
      // Skip duplicate if color hasn't actually changed
      if (last &&
          Math.abs(last[0] - currentL) < 1e-6 &&
          Math.abs(last[1] - currentA) < 1e-6 &&
          Math.abs(last[2] - currentB) < 1e-6) {
        return;
      }
      h.entries.push([currentL, currentA, currentB]);
      if (h.entries.length > MAX_HISTORY) h.entries.shift();
      h.pos = h.entries.length - 1;
    }

    /**
     * Navigate to a history entry and apply its color.
     */
    function applyHistoryEntry(h) {
      const [L, a, b] = h.entries[h.pos];
      currentL = L;
      currentA = a;
      currentB = b;
      writePickerToEditTarget();
      renderAll();
    }

    /**
     * Step backward in the active history (Ctrl+Z).
     */
    function historyBack() {
      const h = getActiveHistory();
      if (h.pos > 0) {
        h.pos--;
        applyHistoryEntry(h);
      }
    }

    /**
     * Step forward in the active history (Ctrl+Shift+Z).
     */
    function historyForward() {
      const h = getActiveHistory();
      if (h.pos < h.entries.length - 1) {
        h.pos++;
        applyHistoryEntry(h);
      }
    }

    // ‚îÄ‚îÄ Keyboard shortcuts ‚îÄ‚îÄ
    window.addEventListener('keydown', (event) => {
      if (event.key === 'z' && event.ctrlKey && !event.shiftKey) {
        event.preventDefault();
        historyBack();
      } else if (event.key === 'Z' && event.ctrlKey && event.shiftKey) {
        event.preventDefault();
        historyForward();
      }
    });
  </script>

</body>
</html>
